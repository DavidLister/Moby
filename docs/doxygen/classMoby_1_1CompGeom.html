<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>Moby: Moby::CompGeom Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Moby
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceMoby.html">Moby</a></li><li class="navelem"><a class="el" href="classMoby_1_1CompGeom.html">CompGeom</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classMoby_1_1CompGeom-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Moby::CompGeom Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Class for performing assorted computational geometry functions.  
 <a href="classMoby_1_1CompGeom.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="CompGeom_8h_source.html">CompGeom.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:abcd0a79d2694f6f1d01fdaae8b196cde"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><b>SegSegIntersectType</b> { <b>eSegSegNoIntersect</b>, 
<b>eSegSegIntersect</b>, 
<b>eSegSegVertex</b>, 
<b>eSegSegEdge</b>
 }</td></tr>
<tr class="separator:abcd0a79d2694f6f1d01fdaae8b196cde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e5ca2a861a811f0daf57b0d70d06da6"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><b>LineLineIntersectType</b> { <b>eLineLineNoIntersect</b>, 
<b>eLineLineIntersect</b>, 
<b>eLineLineVertex</b>, 
<b>eLineLineEdge</b>
 }</td></tr>
<tr class="separator:a4e5ca2a861a811f0daf57b0d70d06da6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9eb7371a44e709493a5253394b916c50"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><b>SegTriIntersectType</b> { <br/>
&#160;&#160;<b>eSegTriNoIntersect</b>, 
<b>eSegTriInclFace</b>, 
<b>eSegTriInclVertex</b>, 
<b>eSegTriInclEdge</b>, 
<br/>
&#160;&#160;<b>eSegTriInside</b>, 
<b>eSegTriVertex</b>, 
<b>eSegTriEdge</b>, 
<b>eSegTriFace</b>, 
<br/>
&#160;&#160;<b>eSegTriEdgeOverlap</b>, 
<b>eSegTriPlanarIntersect</b>
<br/>
 }</td></tr>
<tr class="separator:a9eb7371a44e709493a5253394b916c50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b20f1c6d00782e76b6e6cf35f1df82c"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><b>SegPlaneIntersectType</b> { <br/>
&#160;&#160;<b>eSegPlaneInPlane</b>, 
<b>eSegPlaneToSide</b>, 
<b>eSegPlaneFirst</b>, 
<b>eSegPlaneSecond</b>, 
<br/>
&#160;&#160;<b>eSegPlaneOtherIntersect</b>
<br/>
 }</td></tr>
<tr class="separator:a3b20f1c6d00782e76b6e6cf35f1df82c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add49bcd6e7352252eafcfb7d3eb43362"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><b>PolygonLocationType</b> { <b>ePolygonInside</b>, 
<b>ePolygonOutside</b>, 
<b>ePolygonOnVertex</b>, 
<b>ePolygonOnEdge</b>
 }</td></tr>
<tr class="separator:add49bcd6e7352252eafcfb7d3eb43362"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fad7e27fafc6e19448b50f93f5fe2b1"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><b>SegLocationType</b> { <b>eSegInterior</b>, 
<b>eSegOrigin</b>, 
<b>eSegEndpoint</b>, 
<b>eSegOutside</b>
 }</td></tr>
<tr class="separator:a0fad7e27fafc6e19448b50f93f5fe2b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a089fec88654185312836c8eeba4daf93"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><b>OrientationType</b> { <b>eLeft</b>, 
<b>eOn</b>, 
<b>eRight</b>
 }</td></tr>
<tr class="separator:a089fec88654185312836c8eeba4daf93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7327b07a993015b6be462d9a88b3b36a"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><b>VisibilityType</b> { <b>eVisible</b>, 
<b>eInvisible</b>, 
<b>eCoplanar</b>
 }</td></tr>
<tr class="separator:a7327b07a993015b6be462d9a88b3b36a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a6bbe4ff267941ccd8f2cd4adef7fc55d"><td class="memTemplParams" colspan="2"><a class="anchor" id="a6bbe4ff267941ccd8f2cd4adef7fc55d"></a>
template&lt;class BidirectionalIterator &gt; </td></tr>
<tr class="memitem:a6bbe4ff267941ccd8f2cd4adef7fc55d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMoby_1_1CompGeom.html#a6bbe4ff267941ccd8f2cd4adef7fc55d">diagonalie</a> (BidirectionalIterator a, BidirectionalIterator b, BidirectionalIterator begin, BidirectionalIterator end, double tol)</td></tr>
<tr class="memdesc:a6bbe4ff267941ccd8f2cd4adef7fc55d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility method for <a class="el" href="classMoby_1_1CompGeom.html#a5841bb99e1471e9416786db68b8b6d9f" title="Triangulates a polygon (in 2D) ">triangulate_polygon_2D()</a> <br/></td></tr>
<tr class="separator:a6bbe4ff267941ccd8f2cd4adef7fc55d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae7a6a30c0c190bc2b27795141f64310"><td class="memTemplParams" colspan="2"><a class="anchor" id="aae7a6a30c0c190bc2b27795141f64310"></a>
template&lt;class BidirectionalIterator &gt; </td></tr>
<tr class="memitem:aae7a6a30c0c190bc2b27795141f64310"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMoby_1_1CompGeom.html#aae7a6a30c0c190bc2b27795141f64310">diagonal</a> (BidirectionalIterator a, BidirectionalIterator b, BidirectionalIterator begin, BidirectionalIterator end, double tol)</td></tr>
<tr class="memdesc:aae7a6a30c0c190bc2b27795141f64310"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility method for <a class="el" href="classMoby_1_1CompGeom.html#a5841bb99e1471e9416786db68b8b6d9f" title="Triangulates a polygon (in 2D) ">triangulate_polygon_2D()</a> <br/></td></tr>
<tr class="separator:aae7a6a30c0c190bc2b27795141f64310"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abeee50ee9fa1a4216a125cd0487cbd1d"><td class="memTemplParams" colspan="2"><a class="anchor" id="abeee50ee9fa1a4216a125cd0487cbd1d"></a>
template&lt;class BidirectionalIterator &gt; </td></tr>
<tr class="memitem:abeee50ee9fa1a4216a125cd0487cbd1d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMoby_1_1CompGeom.html#abeee50ee9fa1a4216a125cd0487cbd1d">in_cone</a> (BidirectionalIterator a, BidirectionalIterator b, BidirectionalIterator begin, BidirectionalIterator end, double tol)</td></tr>
<tr class="memdesc:abeee50ee9fa1a4216a125cd0487cbd1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility method for <a class="el" href="classMoby_1_1CompGeom.html#a5841bb99e1471e9416786db68b8b6d9f" title="Triangulates a polygon (in 2D) ">triangulate_polygon_2D()</a> <br/></td></tr>
<tr class="separator:abeee50ee9fa1a4216a125cd0487cbd1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab478434f45c68c365ceca762b77ffc0e"><td class="memTemplParams" colspan="2">template&lt;class BidirectionalIterator , class OutputIterator &gt; </td></tr>
<tr class="memitem:ab478434f45c68c365ceca762b77ffc0e"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMoby_1_1CompGeom.html#ab478434f45c68c365ceca762b77ffc0e">triangulate_polygon_2D</a> (BidirectionalIterator begin, BidirectionalIterator end, OutputIterator outbegin, double tol)</td></tr>
<tr class="memdesc:ab478434f45c68c365ceca762b77ffc0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Triangulates a polygon (in 2D)  <a href="#ab478434f45c68c365ceca762b77ffc0e">More...</a><br/></td></tr>
<tr class="separator:ab478434f45c68c365ceca762b77ffc0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ede08dd68d71081f5bd1d6ade4e0b85"><td class="memTemplParams" colspan="2">template&lt;class ForwardIterator &gt; </td></tr>
<tr class="memitem:a3ede08dd68d71081f5bd1d6ade4e0b85"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceMoby.html#a846eb82dfba26e708e01316dc47a3e39">Point3d</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMoby_1_1CompGeom.html#a3ede08dd68d71081f5bd1d6ade4e0b85">calc_centroid_3D</a> (ForwardIterator first, ForwardIterator last)</td></tr>
<tr class="memdesc:a3ede08dd68d71081f5bd1d6ade4e0b85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the centroid of a set of facets.  <a href="#a3ede08dd68d71081f5bd1d6ade4e0b85">More...</a><br/></td></tr>
<tr class="separator:a3ede08dd68d71081f5bd1d6ade4e0b85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22097b53c6e87ff29ed42bbbdabc8478"><td class="memTemplParams" colspan="2">template&lt;class ForwardIterator &gt; </td></tr>
<tr class="memitem:a22097b53c6e87ff29ed42bbbdabc8478"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMoby_1_1CompGeom.html#a22097b53c6e87ff29ed42bbbdabc8478">determine_seg_endpoints</a> (ForwardIterator begin, ForwardIterator end, std::pair&lt; <a class="el" href="namespaceMoby.html#a846eb82dfba26e708e01316dc47a3e39">Point3d</a> *, <a class="el" href="namespaceMoby.html#a846eb82dfba26e708e01316dc47a3e39">Point3d</a> * &gt; &amp;endpoints)</td></tr>
<tr class="memdesc:a22097b53c6e87ff29ed42bbbdabc8478"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the endpoints for a container of collinear Ravelin::Vector3d objects.  <a href="#a22097b53c6e87ff29ed42bbbdabc8478">More...</a><br/></td></tr>
<tr class="separator:a22097b53c6e87ff29ed42bbbdabc8478"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bdff8fb5024a463973d9bbe5ab3e04a"><td class="memTemplParams" colspan="2">template&lt;class ForwardIterator &gt; </td></tr>
<tr class="memitem:a8bdff8fb5024a463973d9bbe5ab3e04a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMoby_1_1CompGeom.html#a8bdff8fb5024a463973d9bbe5ab3e04a">determine_seg_endpoints</a> (ForwardIterator begin, ForwardIterator end, std::pair&lt; <a class="el" href="namespaceMoby.html#a846eb82dfba26e708e01316dc47a3e39">Point3d</a>, <a class="el" href="namespaceMoby.html#a846eb82dfba26e708e01316dc47a3e39">Point3d</a> &gt; &amp;endpoints)</td></tr>
<tr class="memdesc:a8bdff8fb5024a463973d9bbe5ab3e04a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the endpoints for a container of collinear Ravelin::Vector3d objects.  <a href="#a8bdff8fb5024a463973d9bbe5ab3e04a">More...</a><br/></td></tr>
<tr class="separator:a8bdff8fb5024a463973d9bbe5ab3e04a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8998c302ec5a93179f153711866cae73"><td class="memTemplParams" colspan="2">template&lt;class ForwardIterator &gt; </td></tr>
<tr class="memitem:a8998c302ec5a93179f153711866cae73"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMoby_1_1CompGeom.html#a8998c302ec5a93179f153711866cae73">determine_seg_endpoints</a> (ForwardIterator begin, ForwardIterator end, std::pair&lt; <a class="el" href="namespaceMoby.html#ad8a5998be346e36d61d73fb858461b58">Point2d</a>, <a class="el" href="namespaceMoby.html#ad8a5998be346e36d61d73fb858461b58">Point2d</a> &gt; &amp;endpoints)</td></tr>
<tr class="memdesc:a8998c302ec5a93179f153711866cae73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the endpoints for a container of collinear Point2d objects.  <a href="#a8998c302ec5a93179f153711866cae73">More...</a><br/></td></tr>
<tr class="separator:a8998c302ec5a93179f153711866cae73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f3043f986e07262c02dba6be84170e6"><td class="memTemplParams" colspan="2">template&lt;class ForwardIterator &gt; </td></tr>
<tr class="memitem:a6f3043f986e07262c02dba6be84170e6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMoby_1_1CompGeom.html#a6f3043f986e07262c02dba6be84170e6">determine_seg_endpoints</a> (ForwardIterator begin, ForwardIterator end, std::pair&lt; <a class="el" href="namespaceMoby.html#ad8a5998be346e36d61d73fb858461b58">Point2d</a> *, <a class="el" href="namespaceMoby.html#ad8a5998be346e36d61d73fb858461b58">Point2d</a> * &gt; &amp;endpoints)</td></tr>
<tr class="memdesc:a6f3043f986e07262c02dba6be84170e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the endpoints for a container of collinear Point2d* objects.  <a href="#a6f3043f986e07262c02dba6be84170e6">More...</a><br/></td></tr>
<tr class="separator:a6f3043f986e07262c02dba6be84170e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a523384bf1a484781696fea303fb54d92"><td class="memTemplParams" colspan="2">template&lt;class ForwardIterator , class OutputIterator &gt; </td></tr>
<tr class="memitem:a523384bf1a484781696fea303fb54d92"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMoby_1_1CompGeom.html#a523384bf1a484781696fea303fb54d92">intersect_seg_polygon</a> (ForwardIterator begin, ForwardIterator end, const <a class="el" href="namespaceMoby.html#ac1e78acf3c1ee806a04bb6d35eadcf46">LineSeg2</a> &amp;seg, OutputIterator outbegin)</td></tr>
<tr class="memdesc:a523384bf1a484781696fea303fb54d92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the intersection of a polygon and a line segment.  <a href="#a523384bf1a484781696fea303fb54d92">More...</a><br/></td></tr>
<tr class="separator:a523384bf1a484781696fea303fb54d92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa631bbdb5504678d2d844735002cca6"><td class="memTemplParams" colspan="2">template&lt;class ForwardIterator &gt; </td></tr>
<tr class="memitem:afa631bbdb5504678d2d844735002cca6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceMoby.html#addf6a9597fd5786651d804e5aef9a4c6">TessellatedPolyhedronPtr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMoby_1_1CompGeom.html#afa631bbdb5504678d2d844735002cca6">calc_convex_hull</a> (ForwardIterator first, ForwardIterator last)</td></tr>
<tr class="memdesc:afa631bbdb5504678d2d844735002cca6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the 3D convex hull of a set of points.  <a href="#afa631bbdb5504678d2d844735002cca6">More...</a><br/></td></tr>
<tr class="separator:afa631bbdb5504678d2d844735002cca6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a4c756ab335e006ef110377beeadd2e"><td class="memTemplParams" colspan="2">template&lt;class ForwardIterator &gt; </td></tr>
<tr class="memitem:a3a4c756ab335e006ef110377beeadd2e"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMoby_1_1CompGeom.html#a3a4c756ab335e006ef110377beeadd2e">find_hs_interior_point</a> (ForwardIterator start, ForwardIterator end, Ravelin::Origin3d &amp;point)</td></tr>
<tr class="memdesc:a3a4c756ab335e006ef110377beeadd2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds an interior point of a set of halfspaces using linear programming.  <a href="#a3a4c756ab335e006ef110377beeadd2e">More...</a><br/></td></tr>
<tr class="separator:a3a4c756ab335e006ef110377beeadd2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fc3346ba45a1cc96ab7781ec732106e"><td class="memTemplParams" colspan="2">template&lt;class ForwardIterator &gt; </td></tr>
<tr class="memitem:a0fc3346ba45a1cc96ab7781ec732106e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceMoby.html#addf6a9597fd5786651d804e5aef9a4c6">TessellatedPolyhedronPtr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMoby_1_1CompGeom.html#a0fc3346ba45a1cc96ab7781ec732106e">calc_hs_intersection</a> (ForwardIterator start, ForwardIterator end, const Ravelin::Origin3d &amp;interior_point)</td></tr>
<tr class="memdesc:a0fc3346ba45a1cc96ab7781ec732106e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the halfspace intersection, returning the result as a convex polyhedron.  <a href="#a0fc3346ba45a1cc96ab7781ec732106e">More...</a><br/></td></tr>
<tr class="separator:a0fc3346ba45a1cc96ab7781ec732106e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0941a988f842850c466f497269719312"><td class="memTemplParams" colspan="2">template&lt;class ForwardIterator &gt; </td></tr>
<tr class="memitem:a0941a988f842850c466f497269719312"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMoby_1_1CompGeom.html#a0941a988f842850c466f497269719312">intersect_seg_convex_polygon</a> (ForwardIterator begin, ForwardIterator end, const <a class="el" href="namespaceMoby.html#ac1e78acf3c1ee806a04bb6d35eadcf46">LineSeg2</a> &amp;seg, double &amp;te, double &amp;tl, double tol)</td></tr>
<tr class="memdesc:a0941a988f842850c466f497269719312"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the intersection of a convex polygon and a line segment.  <a href="#a0941a988f842850c466f497269719312">More...</a><br/></td></tr>
<tr class="separator:a0941a988f842850c466f497269719312"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a7cdc93c837ca7dfb50316ce0987221"><td class="memTemplParams" colspan="2">template&lt;class ForwardIterator , class OutputIterator &gt; </td></tr>
<tr class="memitem:a0a7cdc93c837ca7dfb50316ce0987221"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMoby_1_1CompGeom.html#a0a7cdc93c837ca7dfb50316ce0987221">to_2D</a> (ForwardIterator begin_source, ForwardIterator end_source, const Ravelin::Matrix3d &amp;R, OutputIterator begin_target)</td></tr>
<tr class="separator:a0a7cdc93c837ca7dfb50316ce0987221"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4a9a799d9237b6f0e2a11ece24b39cd"><td class="memTemplParams" colspan="2">template&lt;class ForwardIterator , class OutputIterator &gt; </td></tr>
<tr class="memitem:ac4a9a799d9237b6f0e2a11ece24b39cd"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMoby_1_1CompGeom.html#ac4a9a799d9237b6f0e2a11ece24b39cd">to_3D</a> (ForwardIterator begin_source, ForwardIterator end_source, OutputIterator begin_target, const Ravelin::Matrix3d &amp;RT, double offset)</td></tr>
<tr class="separator:ac4a9a799d9237b6f0e2a11ece24b39cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f8be3ca00f0e286d61a978bc6bec573"><td class="memTemplParams" colspan="2">template&lt;class ForwardIterator &gt; </td></tr>
<tr class="memitem:a2f8be3ca00f0e286d61a978bc6bec573"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMoby_1_1CompGeom.html#a2f8be3ca00f0e286d61a978bc6bec573">ccw</a> (ForwardIterator begin, ForwardIterator end, double tol)</td></tr>
<tr class="separator:a2f8be3ca00f0e286d61a978bc6bec573"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31d412921ddd9f15f0d5bfa889ef2ce8"><td class="memTemplParams" colspan="2">template&lt;class ForwardIterator &gt; </td></tr>
<tr class="memitem:a31d412921ddd9f15f0d5bfa889ef2ce8"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMoby_1_1CompGeom.html#a31d412921ddd9f15f0d5bfa889ef2ce8">ccw</a> (ForwardIterator begin, ForwardIterator end, const Ravelin::Vector3d &amp;normal, double tol)</td></tr>
<tr class="separator:a31d412921ddd9f15f0d5bfa889ef2ce8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9e08a7ade06867db6636a7f68375af0"><td class="memTemplParams" colspan="2">template&lt;class OutputIterator &gt; </td></tr>
<tr class="memitem:af9e08a7ade06867db6636a7f68375af0"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMoby_1_1CompGeom.html#af9e08a7ade06867db6636a7f68375af0">intersect_coplanar_tris</a> (const <a class="el" href="classMoby_1_1Triangle.html">Triangle</a> &amp;t1, const <a class="el" href="classMoby_1_1Triangle.html">Triangle</a> &amp;t2, const Ravelin::Vector3d &amp;normal, OutputIterator begin)</td></tr>
<tr class="memdesc:af9e08a7ade06867db6636a7f68375af0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intersects two coplanar triangles.  <a href="#af9e08a7ade06867db6636a7f68375af0">More...</a><br/></td></tr>
<tr class="separator:af9e08a7ade06867db6636a7f68375af0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4930b94d5cbbd573eaffe777a2b24d06"><td class="memTemplParams" colspan="2">template&lt;class ForwardIterator , class OutputIterator &gt; </td></tr>
<tr class="memitem:a4930b94d5cbbd573eaffe777a2b24d06"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMoby_1_1CompGeom.html#a4930b94d5cbbd573eaffe777a2b24d06">intersect_convex_polygons</a> (ForwardIterator pbegin, ForwardIterator pend, ForwardIterator qbegin, ForwardIterator qend, const Ravelin::Vector3d &amp;normal, OutputIterator isect_begin)</td></tr>
<tr class="memdesc:a4930b94d5cbbd573eaffe777a2b24d06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intersects two polygons in 3D.  <a href="#a4930b94d5cbbd573eaffe777a2b24d06">More...</a><br/></td></tr>
<tr class="separator:a4930b94d5cbbd573eaffe777a2b24d06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dc207e68d29e300a53d81eff59ccc1f"><td class="memTemplParams" colspan="2">template&lt;class ForwardIterator , class OutputIterator &gt; </td></tr>
<tr class="memitem:a3dc207e68d29e300a53d81eff59ccc1f"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMoby_1_1CompGeom.html#a3dc207e68d29e300a53d81eff59ccc1f">intersect_convex_polygons</a> (ForwardIterator pbegin, ForwardIterator pend, ForwardIterator qbegin, ForwardIterator qend, OutputIterator isect_begin)</td></tr>
<tr class="memdesc:a3dc207e68d29e300a53d81eff59ccc1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intersects two convex polygons in 2D.  <a href="#a3dc207e68d29e300a53d81eff59ccc1f">More...</a><br/></td></tr>
<tr class="separator:a3dc207e68d29e300a53d81eff59ccc1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22d8b75e9a271b21feb44f9b2a49fafb"><td class="memTemplParams" colspan="2">template&lt;class OutputIterator &gt; </td></tr>
<tr class="memitem:a22d8b75e9a271b21feb44f9b2a49fafb"><td class="memTemplItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMoby_1_1CompGeom.html#a22d8b75e9a271b21feb44f9b2a49fafb">advance</a> (unsigned a, unsigned *aa, unsigned n, bool inside, const <a class="el" href="namespaceMoby.html#ad8a5998be346e36d61d73fb858461b58">Point2d</a> &amp;p, OutputIterator &amp;current)</td></tr>
<tr class="memdesc:a22d8b75e9a271b21feb44f9b2a49fafb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function for <a class="el" href="classMoby_1_1CompGeom.html#af9e08a7ade06867db6636a7f68375af0" title="Intersects two coplanar triangles. ">intersect_coplanar_tris()</a>  <a href="#a22d8b75e9a271b21feb44f9b2a49fafb">More...</a><br/></td></tr>
<tr class="separator:a22d8b75e9a271b21feb44f9b2a49fafb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79f90f64a73d5111201fb2b624e8f779"><td class="memTemplParams" colspan="2">template&lt;class OutputIterator &gt; </td></tr>
<tr class="memitem:a79f90f64a73d5111201fb2b624e8f779"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMoby_1_1CompGeom.html#a79f90f64a73d5111201fb2b624e8f779">intersect_tris</a> (const <a class="el" href="classMoby_1_1Triangle.html">Triangle</a> &amp;t1, const <a class="el" href="classMoby_1_1Triangle.html">Triangle</a> &amp;t2, OutputIterator begin)</td></tr>
<tr class="memdesc:a79f90f64a73d5111201fb2b624e8f779"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intersects two triangles in 3D and returns the points of intersection.  <a href="#a79f90f64a73d5111201fb2b624e8f779">More...</a><br/></td></tr>
<tr class="separator:a79f90f64a73d5111201fb2b624e8f779"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8972fb0cb11f9cfb4630a83a8b45f9bc"><td class="memTemplParams" colspan="2">template&lt;class ForwardIterator , class OutputIterator &gt; </td></tr>
<tr class="memitem:a8972fb0cb11f9cfb4630a83a8b45f9bc"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMoby_1_1CompGeom.html#a8972fb0cb11f9cfb4630a83a8b45f9bc">calc_convex_hull</a> (ForwardIterator source_begin, ForwardIterator source_end, OutputIterator target_begin)</td></tr>
<tr class="memdesc:a8972fb0cb11f9cfb4630a83a8b45f9bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the convex hull of a set of points in 2D using quickhull.  <a href="#a8972fb0cb11f9cfb4630a83a8b45f9bc">More...</a><br/></td></tr>
<tr class="separator:a8972fb0cb11f9cfb4630a83a8b45f9bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d1fdfbfa5fee2f3bbea44e22696a9bb"><td class="memTemplParams" colspan="2">template&lt;class ForwardIterator , class OutputIterator &gt; </td></tr>
<tr class="memitem:a6d1fdfbfa5fee2f3bbea44e22696a9bb"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMoby_1_1CompGeom.html#a6d1fdfbfa5fee2f3bbea44e22696a9bb">calc_convex_hull</a> (ForwardIterator source_begin, ForwardIterator source_end, const Ravelin::Vector3d &amp;normal, OutputIterator target_begin)</td></tr>
<tr class="memdesc:a6d1fdfbfa5fee2f3bbea44e22696a9bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the convex hull of a set of points that lie on a 2D manifold using quickhull.  <a href="#a6d1fdfbfa5fee2f3bbea44e22696a9bb">More...</a><br/></td></tr>
<tr class="separator:a6d1fdfbfa5fee2f3bbea44e22696a9bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab271b70d998ed7efab482a8060a9c2fc"><td class="memTemplParams" colspan="2"><a class="anchor" id="ab271b70d998ed7efab482a8060a9c2fc"></a>
template&lt;class ForwardIterator &gt; </td></tr>
<tr class="memitem:ab271b70d998ed7efab482a8060a9c2fc"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMoby_1_1CompGeom.html#ab271b70d998ed7efab482a8060a9c2fc">is_convex_polygon</a> (ForwardIterator begin, ForwardIterator end, double tol)</td></tr>
<tr class="memdesc:ab271b70d998ed7efab482a8060a9c2fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether a polygon in 2D is convex. <br/></td></tr>
<tr class="separator:ab271b70d998ed7efab482a8060a9c2fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a448f5465e9c9b2e8753dcab2161b3d40"><td class="memTemplParams" colspan="2"><a class="anchor" id="a448f5465e9c9b2e8753dcab2161b3d40"></a>
template&lt;class ForwardIterator &gt; </td></tr>
<tr class="memitem:a448f5465e9c9b2e8753dcab2161b3d40"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMoby_1_1CompGeom.html#a448f5465e9c9b2e8753dcab2161b3d40">is_convex_polygon</a> (ForwardIterator begin, ForwardIterator end, const Ravelin::Vector3d &amp;normal, double tol)</td></tr>
<tr class="memdesc:a448f5465e9c9b2e8753dcab2161b3d40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether a polygon (in 3D) is convex. <br/></td></tr>
<tr class="separator:a448f5465e9c9b2e8753dcab2161b3d40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e37a986917fca0b8a38fffd559b206f"><td class="memTemplParams" colspan="2">template&lt;class ForwardIterator , class OutputIterator &gt; </td></tr>
<tr class="memitem:a8e37a986917fca0b8a38fffd559b206f"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMoby_1_1CompGeom.html#a8e37a986917fca0b8a38fffd559b206f">triangulate_convex_polygon</a> (ForwardIterator source_begin, ForwardIterator source_end, OutputIterator target_begin)</td></tr>
<tr class="memdesc:a8e37a986917fca0b8a38fffd559b206f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Triangulates a convex polygon in O(n)  <a href="#a8e37a986917fca0b8a38fffd559b206f">More...</a><br/></td></tr>
<tr class="separator:a8e37a986917fca0b8a38fffd559b206f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a608392fd29f1b8a9ae94ef4422dde8ed"><td class="memTemplParams" colspan="2">template&lt;class ForwardIterator &gt; </td></tr>
<tr class="memitem:a608392fd29f1b8a9ae94ef4422dde8ed"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMoby_1_1CompGeom.html#a608392fd29f1b8a9ae94ef4422dde8ed">fit_plane</a> (ForwardIterator begin, ForwardIterator end, Ravelin::Vector3d &amp;normal, double &amp;offset)</td></tr>
<tr class="memdesc:a608392fd29f1b8a9ae94ef4422dde8ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to fit a plane to a set of points.  <a href="#a608392fd29f1b8a9ae94ef4422dde8ed">More...</a><br/></td></tr>
<tr class="separator:a608392fd29f1b8a9ae94ef4422dde8ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bb1613349c111d5fdd1f200e0c5f516"><td class="memTemplParams" colspan="2">template&lt;class ForwardIterator &gt; </td></tr>
<tr class="memitem:a5bb1613349c111d5fdd1f200e0c5f516"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMoby_1_1CompGeom.html#a5bb1613349c111d5fdd1f200e0c5f516">project_plane</a> (ForwardIterator begin, ForwardIterator end, const Ravelin::Vector3d &amp;normal, double offset)</td></tr>
<tr class="memdesc:a5bb1613349c111d5fdd1f200e0c5f516"><td class="mdescLeft">&#160;</td><td class="mdescRight">Projects a set of points onto a plane.  <a href="#a5bb1613349c111d5fdd1f200e0c5f516">More...</a><br/></td></tr>
<tr class="separator:a5bb1613349c111d5fdd1f200e0c5f516"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a747cb185724f45bc91a227fc555287"><td class="memTemplParams" colspan="2">template&lt;class ForwardIterator &gt; </td></tr>
<tr class="memitem:a8a747cb185724f45bc91a227fc555287"><td class="memTemplItemLeft" align="right" valign="top">CompGeom::PolygonLocationType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMoby_1_1CompGeom.html#a8a747cb185724f45bc91a227fc555287">polygon_location</a> (ForwardIterator begin, ForwardIterator end, const <a class="el" href="namespaceMoby.html#ad8a5998be346e36d61d73fb858461b58">Point2d</a> &amp;point)</td></tr>
<tr class="memdesc:a8a747cb185724f45bc91a227fc555287"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether a 2D point is inside a polygon.  <a href="#a8a747cb185724f45bc91a227fc555287">More...</a><br/></td></tr>
<tr class="separator:a8a747cb185724f45bc91a227fc555287"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7fcc206f66a3888ddb2c6d7c46d21da"><td class="memTemplParams" colspan="2">template&lt;class ForwardIterator &gt; </td></tr>
<tr class="memitem:aa7fcc206f66a3888ddb2c6d7c46d21da"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMoby_1_1CompGeom.html#aa7fcc206f66a3888ddb2c6d7c46d21da">calc_polygon_area</a> (ForwardIterator begin, ForwardIterator end)</td></tr>
<tr class="memdesc:aa7fcc206f66a3888ddb2c6d7c46d21da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the area of a polygon in 2D.  <a href="#aa7fcc206f66a3888ddb2c6d7c46d21da">More...</a><br/></td></tr>
<tr class="separator:aa7fcc206f66a3888ddb2c6d7c46d21da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a592deedcb8c946e033b3c84eee7b4e18"><td class="memTemplParams" colspan="2">template&lt;class ForwardIterator &gt; </td></tr>
<tr class="memitem:a592deedcb8c946e033b3c84eee7b4e18"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMoby_1_1CompGeom.html#a592deedcb8c946e033b3c84eee7b4e18">calc_polygon_area</a> (ForwardIterator begin, ForwardIterator end, const Ravelin::Vector3d &amp;normal)</td></tr>
<tr class="memdesc:a592deedcb8c946e033b3c84eee7b4e18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the area of a polygon in 3D.  <a href="#a592deedcb8c946e033b3c84eee7b4e18">More...</a><br/></td></tr>
<tr class="separator:a592deedcb8c946e033b3c84eee7b4e18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73837ae14eacdde1c00b5c849241479e"><td class="memTemplParams" colspan="2">template&lt;class ForwardIterator &gt; </td></tr>
<tr class="memitem:a73837ae14eacdde1c00b5c849241479e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceMoby.html#ad8a5998be346e36d61d73fb858461b58">Point2d</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMoby_1_1CompGeom.html#a73837ae14eacdde1c00b5c849241479e">calc_centroid_2D</a> (ForwardIterator begin, ForwardIterator end)</td></tr>
<tr class="memdesc:a73837ae14eacdde1c00b5c849241479e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the centroid of points on a plane.  <a href="#a73837ae14eacdde1c00b5c849241479e">More...</a><br/></td></tr>
<tr class="separator:a73837ae14eacdde1c00b5c849241479e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a509ee133796072a2c2f44625c05b55f7"><td class="memTemplParams" colspan="2">template&lt;class ForwardIterator &gt; </td></tr>
<tr class="memitem:a509ee133796072a2c2f44625c05b55f7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceMoby.html#a846eb82dfba26e708e01316dc47a3e39">Point3d</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMoby_1_1CompGeom.html#a509ee133796072a2c2f44625c05b55f7">calc_centroid_2D</a> (ForwardIterator begin, ForwardIterator end, const Ravelin::Vector3d &amp;normal)</td></tr>
<tr class="memdesc:a509ee133796072a2c2f44625c05b55f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the 3D (2D) centroid of points on a plane.  <a href="#a509ee133796072a2c2f44625c05b55f7">More...</a><br/></td></tr>
<tr class="separator:a509ee133796072a2c2f44625c05b55f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1030878667a2a4c9ba268fa653ee9121"><td class="memTemplParams" colspan="2">template&lt;class ForwardIterator &gt; </td></tr>
<tr class="memitem:a1030878667a2a4c9ba268fa653ee9121"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMoby_1_1CompGeom.html#a1030878667a2a4c9ba268fa653ee9121">calc_min_area_bounding_rect</a> (ForwardIterator begin, ForwardIterator end, <a class="el" href="namespaceMoby.html#ad8a5998be346e36d61d73fb858461b58">Point2d</a> &amp;x1, <a class="el" href="namespaceMoby.html#ad8a5998be346e36d61d73fb858461b58">Point2d</a> &amp;x2, <a class="el" href="namespaceMoby.html#ad8a5998be346e36d61d73fb858461b58">Point2d</a> &amp;x3, <a class="el" href="namespaceMoby.html#ad8a5998be346e36d61d73fb858461b58">Point2d</a> &amp;x4)</td></tr>
<tr class="memdesc:a1030878667a2a4c9ba268fa653ee9121"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the minimum area bounding rectangle of a set of points.  <a href="#a1030878667a2a4c9ba268fa653ee9121">More...</a><br/></td></tr>
<tr class="separator:a1030878667a2a4c9ba268fa653ee9121"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c5cb9a3599a7140a39642f5a5cb43af"><td class="memTemplParams" colspan="2">template&lt;class OutputIterator &gt; </td></tr>
<tr class="memitem:a3c5cb9a3599a7140a39642f5a5cb43af"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMoby_1_1CompGeom.html#a3c5cb9a3599a7140a39642f5a5cb43af">intersect_tris</a> (const <a class="el" href="namespaceMoby.html#ad8a5998be346e36d61d73fb858461b58">Point2d</a> t1[3], const <a class="el" href="namespaceMoby.html#ad8a5998be346e36d61d73fb858461b58">Point2d</a> t2[3], OutputIterator output_begin)</td></tr>
<tr class="separator:a3c5cb9a3599a7140a39642f5a5cb43af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa08446fabffcb4e7874232df151aadcb"><td class="memTemplParams" colspan="2"><a class="anchor" id="aa08446fabffcb4e7874232df151aadcb"></a>
template&lt;class OutputIterator &gt; </td></tr>
<tr class="memitem:aa08446fabffcb4e7874232df151aadcb"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMoby_1_1CompGeom.html#aa08446fabffcb4e7874232df151aadcb">intersect_seg_tri</a> (const <a class="el" href="namespaceMoby.html#ac1e78acf3c1ee806a04bb6d35eadcf46">LineSeg2</a> &amp;seg, const <a class="el" href="namespaceMoby.html#ad8a5998be346e36d61d73fb858461b58">Point2d</a> tri[3], OutputIterator output_begin)</td></tr>
<tr class="memdesc:aa08446fabffcb4e7874232df151aadcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intersects a line segment and a triangle in 2D. <br/></td></tr>
<tr class="separator:aa08446fabffcb4e7874232df151aadcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2046174c45b7daa63d373c2c9feb3e0"><td class="memTemplParams" colspan="2"><a class="anchor" id="ab2046174c45b7daa63d373c2c9feb3e0"></a>
template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:ab2046174c45b7daa63d373c2c9feb3e0"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMoby_1_1CompGeom.html#ab2046174c45b7daa63d373c2c9feb3e0">determine_line_param</a> (const T &amp;p0, const U &amp;dir, const T &amp;v)</td></tr>
<tr class="memdesc:ab2046174c45b7daa63d373c2c9feb3e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the parameter of a point on a line, v = p0 + dir*t, -inf &lt;= t &lt;= inf. <br/></td></tr>
<tr class="separator:ab2046174c45b7daa63d373c2c9feb3e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47ded4bb24a0e1fa01c7500233250cff"><td class="memTemplParams" colspan="2">template&lt;class OutputIterator &gt; </td></tr>
<tr class="memitem:a47ded4bb24a0e1fa01c7500233250cff"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMoby_1_1CompGeom.html#a47ded4bb24a0e1fa01c7500233250cff">intersect_segs</a> (const <a class="el" href="namespaceMoby.html#ac1e78acf3c1ee806a04bb6d35eadcf46">LineSeg2</a> &amp;s1, const <a class="el" href="namespaceMoby.html#ac1e78acf3c1ee806a04bb6d35eadcf46">LineSeg2</a> &amp;s2, OutputIterator output_begin)</td></tr>
<tr class="memdesc:a47ded4bb24a0e1fa01c7500233250cff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intersects two line segments in 2D.  <a href="#a47ded4bb24a0e1fa01c7500233250cff">More...</a><br/></td></tr>
<tr class="separator:a47ded4bb24a0e1fa01c7500233250cff"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a882848408141e876a4260a7dad6b33c9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a882848408141e876a4260a7dad6b33c9"></a>
static SegLocationType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMoby_1_1CompGeom.html#a882848408141e876a4260a7dad6b33c9">determine_seg_location</a> (const <a class="el" href="namespaceMoby.html#ad691671b09efaee22f1758f1a1c3b2de">LineSeg3</a> &amp;seg, double t)</td></tr>
<tr class="memdesc:a882848408141e876a4260a7dad6b33c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the feature for a line segment given a parameter. <br/></td></tr>
<tr class="separator:a882848408141e876a4260a7dad6b33c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f7e5980aa507c8fbd3d956d268df4a1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2f7e5980aa507c8fbd3d956d268df4a1"></a>
static SegLocationType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMoby_1_1CompGeom.html#a2f7e5980aa507c8fbd3d956d268df4a1">determine_seg_location</a> (const <a class="el" href="namespaceMoby.html#ac1e78acf3c1ee806a04bb6d35eadcf46">LineSeg2</a> &amp;seg, double t)</td></tr>
<tr class="memdesc:a2f7e5980aa507c8fbd3d956d268df4a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the feature for a line segment given a parameter. <br/></td></tr>
<tr class="separator:a2f7e5980aa507c8fbd3d956d268df4a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb0bea56f95f3fa94badb64d658fafcf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acb0bea56f95f3fa94badb64d658fafcf"></a>
static unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMoby_1_1CompGeom.html#acb0bea56f95f3fa94badb64d658fafcf">get_num_intersects</a> (SegSegIntersectType t)</td></tr>
<tr class="memdesc:acb0bea56f95f3fa94badb64d658fafcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of intersections for a seg/seg intersection code. <br/></td></tr>
<tr class="separator:acb0bea56f95f3fa94badb64d658fafcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b2a6bdf60ec9788f11bb90da3c0e239"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1b2a6bdf60ec9788f11bb90da3c0e239"></a>
static unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMoby_1_1CompGeom.html#a1b2a6bdf60ec9788f11bb90da3c0e239">get_num_intersects</a> (SegTriIntersectType t)</td></tr>
<tr class="memdesc:a1b2a6bdf60ec9788f11bb90da3c0e239"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of intersections for a seg/tri intersection code. <br/></td></tr>
<tr class="separator:a1b2a6bdf60ec9788f11bb90da3c0e239"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab117375338f54ae1476605214b6bbc49"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab117375338f54ae1476605214b6bbc49"></a>
static unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMoby_1_1CompGeom.html#ab117375338f54ae1476605214b6bbc49">get_num_intersects</a> (LineLineIntersectType t)</td></tr>
<tr class="memdesc:ab117375338f54ae1476605214b6bbc49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of intersections for a line/line intersection code. <br/></td></tr>
<tr class="separator:ab117375338f54ae1476605214b6bbc49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60f9f05ce9e4d3bd8c646671a2ed1841"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a60f9f05ce9e4d3bd8c646671a2ed1841"></a>
static double&#160;</td><td class="memItemRight" valign="bottom"><b>determine_3D_to_2D_offset</b> (const Ravelin::Origin3d &amp;o, const Ravelin::Matrix3d &amp;R)</td></tr>
<tr class="separator:a60f9f05ce9e4d3bd8c646671a2ed1841"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ff779447027e4a1d13d7fc5279469c6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6ff779447027e4a1d13d7fc5279469c6"></a>
static double&#160;</td><td class="memItemRight" valign="bottom"><b>determine_3D_to_2D_offset</b> (const Ravelin::Vector3d &amp;o, const Ravelin::Matrix3d &amp;R)</td></tr>
<tr class="separator:a6ff779447027e4a1d13d7fc5279469c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9b1523c6bc8c1492d0242829ed43a2d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad9b1523c6bc8c1492d0242829ed43a2d"></a>
static Ravelin::Matrix3d&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMoby_1_1CompGeom.html#ad9b1523c6bc8c1492d0242829ed43a2d">calc_3D_to_2D_matrix</a> (const Ravelin::Vector3d &amp;normal)</td></tr>
<tr class="memdesc:ad9b1523c6bc8c1492d0242829ed43a2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the projection matrix to convert from 3D to 2D. <br/></td></tr>
<tr class="separator:ad9b1523c6bc8c1492d0242829ed43a2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89bf3c4c1698de8a8ef0e385d1d68eef"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a89bf3c4c1698de8a8ef0e385d1d68eef"></a>
static <a class="el" href="namespaceMoby.html#a846eb82dfba26e708e01316dc47a3e39">Point3d</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMoby_1_1CompGeom.html#a89bf3c4c1698de8a8ef0e385d1d68eef">generate_point_on_plane</a> (const Ravelin::Vector3d &amp;normal, double d)</td></tr>
<tr class="memdesc:a89bf3c4c1698de8a8ef0e385d1d68eef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a point on a plane. <br/></td></tr>
<tr class="separator:a89bf3c4c1698de8a8ef0e385d1d68eef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaf7f5009c495acb1e0ed8b61890023b"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMoby_1_1CompGeom.html#afaf7f5009c495acb1e0ed8b61890023b">intersect_noncoplanar_tris</a> (const <a class="el" href="classMoby_1_1Triangle.html">Triangle</a> &amp;t1, const <a class="el" href="classMoby_1_1Triangle.html">Triangle</a> &amp;t2, <a class="el" href="namespaceMoby.html#a846eb82dfba26e708e01316dc47a3e39">Point3d</a> &amp;p1, <a class="el" href="namespaceMoby.html#a846eb82dfba26e708e01316dc47a3e39">Point3d</a> &amp;p2)</td></tr>
<tr class="memdesc:afaf7f5009c495acb1e0ed8b61890023b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intersects two non-coplanar triangles in 3D and returns the line of intersection.  <a href="#afaf7f5009c495acb1e0ed8b61890023b">More...</a><br/></td></tr>
<tr class="separator:afaf7f5009c495acb1e0ed8b61890023b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ce296f8404a7c20fdf3abf4ee43b455"><td class="memItemLeft" align="right" valign="top">static SegTriIntersectType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMoby_1_1CompGeom.html#a3ce296f8404a7c20fdf3abf4ee43b455">intersect_seg_tri</a> (const <a class="el" href="namespaceMoby.html#ad691671b09efaee22f1758f1a1c3b2de">LineSeg3</a> &amp;seg, const <a class="el" href="classMoby_1_1Triangle.html">Triangle</a> &amp;t, <a class="el" href="namespaceMoby.html#a846eb82dfba26e708e01316dc47a3e39">Point3d</a> &amp;isect, <a class="el" href="namespaceMoby.html#a846eb82dfba26e708e01316dc47a3e39">Point3d</a> &amp;isect2, double tol=NEAR_ZERO)</td></tr>
<tr class="memdesc:a3ce296f8404a7c20fdf3abf4ee43b455"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the intersection between a line segment and triangle in 3D.  <a href="#a3ce296f8404a7c20fdf3abf4ee43b455">More...</a><br/></td></tr>
<tr class="separator:a3ce296f8404a7c20fdf3abf4ee43b455"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace838946d44581b9ca8a4b96e105b45b"><td class="memItemLeft" align="right" valign="top">static SegTriIntersectType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMoby_1_1CompGeom.html#ace838946d44581b9ca8a4b96e105b45b">intersect_seg_tri</a> (const <a class="el" href="namespaceMoby.html#ac1e78acf3c1ee806a04bb6d35eadcf46">LineSeg2</a> &amp;seg, const <a class="el" href="namespaceMoby.html#ad8a5998be346e36d61d73fb858461b58">Point2d</a> tri[3], <a class="el" href="namespaceMoby.html#ad8a5998be346e36d61d73fb858461b58">Point2d</a> &amp;isect, <a class="el" href="namespaceMoby.html#ad8a5998be346e36d61d73fb858461b58">Point2d</a> &amp;isect2, double tol=NEAR_ZERO)</td></tr>
<tr class="memdesc:ace838946d44581b9ca8a4b96e105b45b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the intersection between a line segment and triangle in 2D.  <a href="#ace838946d44581b9ca8a4b96e105b45b">More...</a><br/></td></tr>
<tr class="separator:ace838946d44581b9ca8a4b96e105b45b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5ddbc91ac40cdf7cfb1531aba4513ed"><td class="memItemLeft" align="right" valign="top">static SegSegIntersectType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMoby_1_1CompGeom.html#ab5ddbc91ac40cdf7cfb1531aba4513ed">intersect_segs</a> (const <a class="el" href="namespaceMoby.html#ad691671b09efaee22f1758f1a1c3b2de">LineSeg3</a> &amp;s1, const <a class="el" href="namespaceMoby.html#ad691671b09efaee22f1758f1a1c3b2de">LineSeg3</a> &amp;s2, <a class="el" href="namespaceMoby.html#a846eb82dfba26e708e01316dc47a3e39">Point3d</a> &amp;isect, <a class="el" href="namespaceMoby.html#a846eb82dfba26e708e01316dc47a3e39">Point3d</a> &amp;isect2)</td></tr>
<tr class="memdesc:ab5ddbc91ac40cdf7cfb1531aba4513ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether two line segments in 3D intersect.  <a href="#ab5ddbc91ac40cdf7cfb1531aba4513ed">More...</a><br/></td></tr>
<tr class="separator:ab5ddbc91ac40cdf7cfb1531aba4513ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5f00906d8a7167a9b94c75169ff1b11"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab5f00906d8a7167a9b94c75169ff1b11"></a>
static double&#160;</td><td class="memItemRight" valign="bottom"><b>intersect_seg_plane</b> (const Ravelin::Vector3d &amp;nrm, double d, const <a class="el" href="namespaceMoby.html#ad691671b09efaee22f1758f1a1c3b2de">LineSeg3</a> &amp;seg)</td></tr>
<tr class="separator:ab5f00906d8a7167a9b94c75169ff1b11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f9edc2b410e801a80df7397b6cd40d3"><td class="memItemLeft" align="right" valign="top">static SegPlaneIntersectType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMoby_1_1CompGeom.html#a7f9edc2b410e801a80df7397b6cd40d3">intersect_seg_plane</a> (const <a class="el" href="classMoby_1_1Triangle.html">Triangle</a> &amp;tri, const <a class="el" href="namespaceMoby.html#ad691671b09efaee22f1758f1a1c3b2de">LineSeg3</a> &amp;seg, <a class="el" href="namespaceMoby.html#a846eb82dfba26e708e01316dc47a3e39">Point3d</a> &amp;isect, unsigned int &amp;big_dim, double tol=NEAR_ZERO)</td></tr>
<tr class="memdesc:a7f9edc2b410e801a80df7397b6cd40d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the intersection between a line segment and a plane in 3D.  <a href="#a7f9edc2b410e801a80df7397b6cd40d3">More...</a><br/></td></tr>
<tr class="separator:a7f9edc2b410e801a80df7397b6cd40d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5634dc46a6c8fcb354a3986ba8fdd825"><td class="memItemLeft" align="right" valign="top">static SegSegIntersectType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMoby_1_1CompGeom.html#a5634dc46a6c8fcb354a3986ba8fdd825">intersect_segs</a> (const <a class="el" href="namespaceMoby.html#ac1e78acf3c1ee806a04bb6d35eadcf46">LineSeg2</a> &amp;s1, const <a class="el" href="namespaceMoby.html#ac1e78acf3c1ee806a04bb6d35eadcf46">LineSeg2</a> &amp;s2, <a class="el" href="namespaceMoby.html#ad8a5998be346e36d61d73fb858461b58">Point2d</a> &amp;isect, <a class="el" href="namespaceMoby.html#ad8a5998be346e36d61d73fb858461b58">Point2d</a> &amp;isect2)</td></tr>
<tr class="memdesc:a5634dc46a6c8fcb354a3986ba8fdd825"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether two line segments in 2D intersect.  <a href="#a5634dc46a6c8fcb354a3986ba8fdd825">More...</a><br/></td></tr>
<tr class="separator:a5634dc46a6c8fcb354a3986ba8fdd825"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae97810ddcc85ef1d4177cb7fa9ce4028"><td class="memItemLeft" align="right" valign="top">static LineLineIntersectType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMoby_1_1CompGeom.html#ae97810ddcc85ef1d4177cb7fa9ce4028">intersect_lines</a> (const <a class="el" href="namespaceMoby.html#ad8a5998be346e36d61d73fb858461b58">Point2d</a> &amp;o1, const Ravelin::Vector2d &amp;dir1, double min1, double max1, const <a class="el" href="namespaceMoby.html#ad8a5998be346e36d61d73fb858461b58">Point2d</a> &amp;o2, const Ravelin::Vector2d &amp;dir2, double min2, double max2, double &amp;s, double &amp;t)</td></tr>
<tr class="memdesc:ae97810ddcc85ef1d4177cb7fa9ce4028"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether two lines/rays/segments in 2D intersect.  <a href="#ae97810ddcc85ef1d4177cb7fa9ce4028">More...</a><br/></td></tr>
<tr class="separator:ae97810ddcc85ef1d4177cb7fa9ce4028"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafe663c880e7656239ddc28c21fda96a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aafe663c880e7656239ddc28c21fda96a"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMoby_1_1CompGeom.html#aafe663c880e7656239ddc28c21fda96a">collinear</a> (const <a class="el" href="namespaceMoby.html#a846eb82dfba26e708e01316dc47a3e39">Point3d</a> &amp;a, const <a class="el" href="namespaceMoby.html#a846eb82dfba26e708e01316dc47a3e39">Point3d</a> &amp;b, const <a class="el" href="namespaceMoby.html#a846eb82dfba26e708e01316dc47a3e39">Point3d</a> &amp;c, double tol=NEAR_ZERO)</td></tr>
<tr class="memdesc:aafe663c880e7656239ddc28c21fda96a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether three points are collinear. <br/></td></tr>
<tr class="separator:aafe663c880e7656239ddc28c21fda96a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a211b6044989fae14ca4f2fd9b095aa6d"><td class="memItemLeft" align="right" valign="top">static PolygonLocationType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMoby_1_1CompGeom.html#a211b6044989fae14ca4f2fd9b095aa6d">in_tri</a> (const <a class="el" href="namespaceMoby.html#ad8a5998be346e36d61d73fb858461b58">Point2d</a> t[3], const <a class="el" href="namespaceMoby.html#ad8a5998be346e36d61d73fb858461b58">Point2d</a> &amp;p, double tol=NEAR_ZERO)</td></tr>
<tr class="memdesc:a211b6044989fae14ca4f2fd9b095aa6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the intersection of a point on a 2D triangle.  <a href="#a211b6044989fae14ca4f2fd9b095aa6d">More...</a><br/></td></tr>
<tr class="separator:a211b6044989fae14ca4f2fd9b095aa6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35c41bdd5c158788e590f89906ce8790"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a35c41bdd5c158788e590f89906ce8790"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMoby_1_1CompGeom.html#a35c41bdd5c158788e590f89906ce8790">collinear</a> (const <a class="el" href="namespaceMoby.html#ad8a5998be346e36d61d73fb858461b58">Point2d</a> &amp;a, const <a class="el" href="namespaceMoby.html#ad8a5998be346e36d61d73fb858461b58">Point2d</a> &amp;b, const <a class="el" href="namespaceMoby.html#ad8a5998be346e36d61d73fb858461b58">Point2d</a> &amp;c, double tol=NEAR_ZERO)</td></tr>
<tr class="memdesc:a35c41bdd5c158788e590f89906ce8790"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether three points are collinear. <br/></td></tr>
<tr class="separator:a35c41bdd5c158788e590f89906ce8790"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94841254817b841faae350e6c98747e4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a94841254817b841faae350e6c98747e4"></a>
static long double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMoby_1_1CompGeom.html#a94841254817b841faae350e6c98747e4">volume</a> (const <a class="el" href="namespaceMoby.html#a846eb82dfba26e708e01316dc47a3e39">Point3d</a> &amp;a, const <a class="el" href="namespaceMoby.html#a846eb82dfba26e708e01316dc47a3e39">Point3d</a> &amp;b, const <a class="el" href="namespaceMoby.html#a846eb82dfba26e708e01316dc47a3e39">Point3d</a> &amp;c, const <a class="el" href="namespaceMoby.html#a846eb82dfba26e708e01316dc47a3e39">Point3d</a> &amp;d)</td></tr>
<tr class="memdesc:a94841254817b841faae350e6c98747e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the volume of a tetrahedron composed of vertices a, b, c, d. <br/></td></tr>
<tr class="separator:a94841254817b841faae350e6c98747e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f08936a1f914f28bf42c126c7fd21f7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4f08936a1f914f28bf42c126c7fd21f7"></a>
static long double&#160;</td><td class="memItemRight" valign="bottom"><b>volume</b> (const Ravelin::Origin3d &amp;a, const Ravelin::Origin3d &amp;b, const Ravelin::Origin3d &amp;c, const Ravelin::Origin3d &amp;d)</td></tr>
<tr class="separator:a4f08936a1f914f28bf42c126c7fd21f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbf2414a41a664c74a56b8162e13f2e6"><td class="memItemLeft" align="right" valign="top">static VisibilityType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMoby_1_1CompGeom.html#adbf2414a41a664c74a56b8162e13f2e6">volume_sign</a> (const <a class="el" href="namespaceMoby.html#a846eb82dfba26e708e01316dc47a3e39">Point3d</a> &amp;a, const <a class="el" href="namespaceMoby.html#a846eb82dfba26e708e01316dc47a3e39">Point3d</a> &amp;b, const <a class="el" href="namespaceMoby.html#a846eb82dfba26e708e01316dc47a3e39">Point3d</a> &amp;c, const <a class="el" href="namespaceMoby.html#a846eb82dfba26e708e01316dc47a3e39">Point3d</a> &amp;d, double tol=NEAR_ZERO)</td></tr>
<tr class="memdesc:adbf2414a41a664c74a56b8162e13f2e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the sign of the volume of a tetrahedron composed of vertices a, b, c, d.  <a href="#adbf2414a41a664c74a56b8162e13f2e6">More...</a><br/></td></tr>
<tr class="separator:adbf2414a41a664c74a56b8162e13f2e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6766262f3940390be2f4d1d9eba11eb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae6766262f3940390be2f4d1d9eba11eb"></a>
static VisibilityType&#160;</td><td class="memItemRight" valign="bottom"><b>volume_sign</b> (const Ravelin::Origin3d &amp;a, const Ravelin::Origin3d &amp;b, const Ravelin::Origin3d &amp;c, const Ravelin::Origin3d &amp;d, double tol=NEAR_ZERO)</td></tr>
<tr class="separator:ae6766262f3940390be2f4d1d9eba11eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a967e941109da1ada334d38a3304cfaae"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a967e941109da1ada334d38a3304cfaae"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMoby_1_1CompGeom.html#a967e941109da1ada334d38a3304cfaae">coplanar</a> (const <a class="el" href="classMoby_1_1Triangle.html">Triangle</a> &amp;t1, const <a class="el" href="classMoby_1_1Triangle.html">Triangle</a> &amp;t2, double tol=NEAR_ZERO)</td></tr>
<tr class="memdesc:a967e941109da1ada334d38a3304cfaae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether two triangles are coplanar. <br/></td></tr>
<tr class="separator:a967e941109da1ada334d38a3304cfaae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3f821015d75b3ca8e636fbf53533410"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af3f821015d75b3ca8e636fbf53533410"></a>
static Ravelin::Origin3d&#160;</td><td class="memItemRight" valign="bottom"><b>to_3D</b> (const Ravelin::Origin2d &amp;p, const Ravelin::Matrix3d &amp;RT)</td></tr>
<tr class="separator:af3f821015d75b3ca8e636fbf53533410"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d10b52e50fc1df3b0096b850dd1cf48"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5d10b52e50fc1df3b0096b850dd1cf48"></a>
static Ravelin::Origin3d&#160;</td><td class="memItemRight" valign="bottom"><b>to_3D</b> (const Ravelin::Origin2d &amp;p, const Ravelin::Matrix3d &amp;RT, double offset)</td></tr>
<tr class="separator:a5d10b52e50fc1df3b0096b850dd1cf48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a366436853777751df1323ad42a39d81e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a366436853777751df1323ad42a39d81e"></a>
static Ravelin::Origin2d&#160;</td><td class="memItemRight" valign="bottom"><b>to_2D</b> (const <a class="el" href="namespaceMoby.html#a846eb82dfba26e708e01316dc47a3e39">Point3d</a> &amp;p, const Ravelin::Matrix3d &amp;R)</td></tr>
<tr class="separator:a366436853777751df1323ad42a39d81e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdee21d20c4672a908dec63e7ac76909"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afdee21d20c4672a908dec63e7ac76909"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMoby_1_1CompGeom.html#afdee21d20c4672a908dec63e7ac76909">point_in_tri</a> (const <a class="el" href="namespaceMoby.html#a846eb82dfba26e708e01316dc47a3e39">Point3d</a> &amp;p, const <a class="el" href="classMoby_1_1Triangle.html">Triangle</a> &amp;t, double tol=NEAR_ZERO)</td></tr>
<tr class="memdesc:afdee21d20c4672a908dec63e7ac76909"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for testing whether a point is in a triangle. <br/></td></tr>
<tr class="separator:afdee21d20c4672a908dec63e7ac76909"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae77c7de911384123fb845450f9fa0cfb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae77c7de911384123fb845450f9fa0cfb"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMoby_1_1CompGeom.html#ae77c7de911384123fb845450f9fa0cfb">coplanar</a> (const <a class="el" href="namespaceMoby.html#a846eb82dfba26e708e01316dc47a3e39">Point3d</a> &amp;a, const <a class="el" href="namespaceMoby.html#a846eb82dfba26e708e01316dc47a3e39">Point3d</a> &amp;b, const <a class="el" href="namespaceMoby.html#a846eb82dfba26e708e01316dc47a3e39">Point3d</a> &amp;c, const <a class="el" href="namespaceMoby.html#a846eb82dfba26e708e01316dc47a3e39">Point3d</a> &amp;d, double tol=NEAR_ZERO)</td></tr>
<tr class="memdesc:ae77c7de911384123fb845450f9fa0cfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether four points are coplanar. <br/></td></tr>
<tr class="separator:ae77c7de911384123fb845450f9fa0cfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c3708070d96e4e756cc725a9633c0a6"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMoby_1_1CompGeom.html#a1c3708070d96e4e756cc725a9633c0a6">calc_dist</a> (const <a class="el" href="namespaceMoby.html#ad691671b09efaee22f1758f1a1c3b2de">LineSeg3</a> &amp;line_seg, const <a class="el" href="namespaceMoby.html#a846eb82dfba26e708e01316dc47a3e39">Point3d</a> &amp;point, double &amp;t, <a class="el" href="namespaceMoby.html#a846eb82dfba26e708e01316dc47a3e39">Point3d</a> &amp;closest)</td></tr>
<tr class="memdesc:a1c3708070d96e4e756cc725a9633c0a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the Euclidean distance between a line segment and a point in 3D.  <a href="#a1c3708070d96e4e756cc725a9633c0a6">More...</a><br/></td></tr>
<tr class="separator:a1c3708070d96e4e756cc725a9633c0a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af37c5dc89a0c39b1a62bd4241223f6dd"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMoby_1_1CompGeom.html#af37c5dc89a0c39b1a62bd4241223f6dd">calc_closest_points</a> (const <a class="el" href="namespaceMoby.html#ad691671b09efaee22f1758f1a1c3b2de">LineSeg3</a> &amp;s1, const <a class="el" href="namespaceMoby.html#ad691671b09efaee22f1758f1a1c3b2de">LineSeg3</a> &amp;s2, <a class="el" href="namespaceMoby.html#a846eb82dfba26e708e01316dc47a3e39">Point3d</a> &amp;p1, <a class="el" href="namespaceMoby.html#a846eb82dfba26e708e01316dc47a3e39">Point3d</a> &amp;p2)</td></tr>
<tr class="memdesc:af37c5dc89a0c39b1a62bd4241223f6dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the shortest line segment between two line segments in 3D.  <a href="#af37c5dc89a0c39b1a62bd4241223f6dd">More...</a><br/></td></tr>
<tr class="separator:af37c5dc89a0c39b1a62bd4241223f6dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83aacfe3503a7e13a714b28b621feaf3"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMoby_1_1CompGeom.html#a83aacfe3503a7e13a714b28b621feaf3">query_intersect_tri_tri</a> (const <a class="el" href="classMoby_1_1Triangle.html">Triangle</a> &amp;t1, const <a class="el" href="classMoby_1_1Triangle.html">Triangle</a> &amp;t2)</td></tr>
<tr class="separator:a83aacfe3503a7e13a714b28b621feaf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89a8fb0483c6a0c8e2922e0bea05143b"><td class="memItemLeft" align="right" valign="top">static PolygonLocationType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMoby_1_1CompGeom.html#a89a8fb0483c6a0c8e2922e0bea05143b">in_tri</a> (const <a class="el" href="classMoby_1_1Triangle.html">Triangle</a> &amp;t, const <a class="el" href="namespaceMoby.html#a846eb82dfba26e708e01316dc47a3e39">Point3d</a> &amp;p, double tol=NEAR_ZERO)</td></tr>
<tr class="memdesc:a89a8fb0483c6a0c8e2922e0bea05143b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the location of a point on a triangle.  <a href="#a89a8fb0483c6a0c8e2922e0bea05143b">More...</a><br/></td></tr>
<tr class="separator:a89a8fb0483c6a0c8e2922e0bea05143b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af26b68deece0470d14e1d7d39a4a9593"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af26b68deece0470d14e1d7d39a4a9593"></a>
static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMoby_1_1CompGeom.html#af26b68deece0470d14e1d7d39a4a9593">sgn</a> (double a, double b, double tol=NEAR_ZERO)</td></tr>
<tr class="memdesc:af26b68deece0470d14e1d7d39a4a9593"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a if b &gt; 0, -a if b &lt; 0, and 0 if b = 0. <br/></td></tr>
<tr class="separator:af26b68deece0470d14e1d7d39a4a9593"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a405fb3b1e042639c67eb8e67283ea28a"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMoby_1_1CompGeom.html#a405fb3b1e042639c67eb8e67283ea28a">rel_equal</a> (double x, double y, double tol=NEAR_ZERO)</td></tr>
<tr class="memdesc:a405fb3b1e042639c67eb8e67283ea28a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether two numbers are relatively/absolutely equal to within some tolerance.  <a href="#a405fb3b1e042639c67eb8e67283ea28a">More...</a><br/></td></tr>
<tr class="separator:a405fb3b1e042639c67eb8e67283ea28a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2a24a5408b36fafb65e55a928419e5a"><td class="memTemplParams" colspan="2"><a class="anchor" id="ab2a24a5408b36fafb65e55a928419e5a"></a>
template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:ab2a24a5408b36fafb65e55a928419e5a"><td class="memTemplItemLeft" align="right" valign="top">static double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMoby_1_1CompGeom.html#ab2a24a5408b36fafb65e55a928419e5a">determine_line_param</a> (const T &amp;p, const U &amp;dir, const T &amp;v)</td></tr>
<tr class="memdesc:ab2a24a5408b36fafb65e55a928419e5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the parameter of a point on a line, v = p0 + dir*t, -inf &lt;= t &lt;= inf. <br/></td></tr>
<tr class="separator:ab2a24a5408b36fafb65e55a928419e5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa08446fabffcb4e7874232df151aadcb"><td class="memTemplParams" colspan="2"><a class="anchor" id="aa08446fabffcb4e7874232df151aadcb"></a>
template&lt;class OutputIterator &gt; </td></tr>
<tr class="memitem:aa08446fabffcb4e7874232df151aadcb"><td class="memTemplItemLeft" align="right" valign="top">static OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMoby_1_1CompGeom.html#aa08446fabffcb4e7874232df151aadcb">intersect_seg_tri</a> (const <a class="el" href="namespaceMoby.html#ac1e78acf3c1ee806a04bb6d35eadcf46">LineSeg2</a> &amp;seg, const <a class="el" href="namespaceMoby.html#ad8a5998be346e36d61d73fb858461b58">Point2d</a> tri[3], OutputIterator output_begin)</td></tr>
<tr class="memdesc:aa08446fabffcb4e7874232df151aadcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intersects a line segment and a triangle in 2D. <br/></td></tr>
<tr class="separator:aa08446fabffcb4e7874232df151aadcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47ded4bb24a0e1fa01c7500233250cff"><td class="memTemplParams" colspan="2">template&lt;class OutputIterator &gt; </td></tr>
<tr class="memitem:a47ded4bb24a0e1fa01c7500233250cff"><td class="memTemplItemLeft" align="right" valign="top">static OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMoby_1_1CompGeom.html#a47ded4bb24a0e1fa01c7500233250cff">intersect_segs</a> (const <a class="el" href="namespaceMoby.html#ac1e78acf3c1ee806a04bb6d35eadcf46">LineSeg2</a> &amp;s1, const <a class="el" href="namespaceMoby.html#ac1e78acf3c1ee806a04bb6d35eadcf46">LineSeg2</a> &amp;s2, OutputIterator output_begin)</td></tr>
<tr class="memdesc:a47ded4bb24a0e1fa01c7500233250cff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intersects two line segments in 2D.  <a href="#a47ded4bb24a0e1fa01c7500233250cff">More...</a><br/></td></tr>
<tr class="separator:a47ded4bb24a0e1fa01c7500233250cff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c5cb9a3599a7140a39642f5a5cb43af"><td class="memTemplParams" colspan="2">template&lt;class OutputIterator &gt; </td></tr>
<tr class="memitem:a3c5cb9a3599a7140a39642f5a5cb43af"><td class="memTemplItemLeft" align="right" valign="top">static OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMoby_1_1CompGeom.html#a3c5cb9a3599a7140a39642f5a5cb43af">intersect_tris</a> (const <a class="el" href="namespaceMoby.html#ad8a5998be346e36d61d73fb858461b58">Point2d</a> t1[3], const <a class="el" href="namespaceMoby.html#ad8a5998be346e36d61d73fb858461b58">Point2d</a> t2[3], OutputIterator output_begin)</td></tr>
<tr class="separator:a3c5cb9a3599a7140a39642f5a5cb43af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00516ed14bbe6b3d5d73273313f03e9c"><td class="memTemplParams" colspan="2">template&lt;class ForwardIterator &gt; </td></tr>
<tr class="memitem:a00516ed14bbe6b3d5d73273313f03e9c"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMoby_1_1CompGeom.html#a00516ed14bbe6b3d5d73273313f03e9c">calc_min_area_bounding_rect</a> (ForwardIterator begin, ForwardIterator end, <a class="el" href="namespaceMoby.html#ad8a5998be346e36d61d73fb858461b58">Point2d</a> &amp;p1, <a class="el" href="namespaceMoby.html#ad8a5998be346e36d61d73fb858461b58">Point2d</a> &amp;p2, <a class="el" href="namespaceMoby.html#ad8a5998be346e36d61d73fb858461b58">Point2d</a> &amp;p3, <a class="el" href="namespaceMoby.html#ad8a5998be346e36d61d73fb858461b58">Point2d</a> &amp;p4)</td></tr>
<tr class="memdesc:a00516ed14bbe6b3d5d73273313f03e9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the minimum area bounding rectangle of a set of points.  <a href="#a00516ed14bbe6b3d5d73273313f03e9c">More...</a><br/></td></tr>
<tr class="separator:a00516ed14bbe6b3d5d73273313f03e9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4930b94d5cbbd573eaffe777a2b24d06"><td class="memTemplParams" colspan="2">template&lt;class ForwardIterator , class OutputIterator &gt; </td></tr>
<tr class="memitem:a4930b94d5cbbd573eaffe777a2b24d06"><td class="memTemplItemLeft" align="right" valign="top">static OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMoby_1_1CompGeom.html#a4930b94d5cbbd573eaffe777a2b24d06">intersect_convex_polygons</a> (ForwardIterator pbegin, ForwardIterator pend, ForwardIterator qbegin, ForwardIterator qend, const Ravelin::Vector3d &amp;normal, OutputIterator isect_begin)</td></tr>
<tr class="memdesc:a4930b94d5cbbd573eaffe777a2b24d06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intersects two polygons in 3D.  <a href="#a4930b94d5cbbd573eaffe777a2b24d06">More...</a><br/></td></tr>
<tr class="separator:a4930b94d5cbbd573eaffe777a2b24d06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dc207e68d29e300a53d81eff59ccc1f"><td class="memTemplParams" colspan="2">template&lt;class ForwardIterator , class OutputIterator &gt; </td></tr>
<tr class="memitem:a3dc207e68d29e300a53d81eff59ccc1f"><td class="memTemplItemLeft" align="right" valign="top">static OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMoby_1_1CompGeom.html#a3dc207e68d29e300a53d81eff59ccc1f">intersect_convex_polygons</a> (ForwardIterator pbegin, ForwardIterator pend, ForwardIterator qbegin, ForwardIterator qend, OutputIterator isect_begin)</td></tr>
<tr class="memdesc:a3dc207e68d29e300a53d81eff59ccc1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intersects two convex polygons in 2D.  <a href="#a3dc207e68d29e300a53d81eff59ccc1f">More...</a><br/></td></tr>
<tr class="separator:a3dc207e68d29e300a53d81eff59ccc1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f5ad993e3f75a893f69bc4261616dfa"><td class="memTemplParams" colspan="2">template&lt;class ForwardIterator &gt; </td></tr>
<tr class="memitem:a7f5ad993e3f75a893f69bc4261616dfa"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMoby_1_1CompGeom.html#a7f5ad993e3f75a893f69bc4261616dfa">ccw</a> (ForwardIterator begin, ForwardIterator end, const Ravelin::Vector3d &amp;normal, double tol=NEAR_ZERO)</td></tr>
<tr class="separator:a7f5ad993e3f75a893f69bc4261616dfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a742c33a9b4ca93a3ee341d271e8e7762"><td class="memTemplParams" colspan="2">template&lt;class ForwardIterator &gt; </td></tr>
<tr class="memitem:a742c33a9b4ca93a3ee341d271e8e7762"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMoby_1_1CompGeom.html#a742c33a9b4ca93a3ee341d271e8e7762">ccw</a> (ForwardIterator begin, ForwardIterator end, double tol=NEAR_ZERO)</td></tr>
<tr class="separator:a742c33a9b4ca93a3ee341d271e8e7762"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae68d8038b15cca7cabc1eaf8e6b828fd"><td class="memTemplParams" colspan="2"><a class="anchor" id="ae68d8038b15cca7cabc1eaf8e6b828fd"></a>
template&lt;class ForwardIterator &gt; </td></tr>
<tr class="memitem:ae68d8038b15cca7cabc1eaf8e6b828fd"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMoby_1_1CompGeom.html#ae68d8038b15cca7cabc1eaf8e6b828fd">is_convex_polygon</a> (ForwardIterator begin, ForwardIterator end, double tol=NEAR_ZERO)</td></tr>
<tr class="memdesc:ae68d8038b15cca7cabc1eaf8e6b828fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether a polygon in 2D is convex. <br/></td></tr>
<tr class="separator:ae68d8038b15cca7cabc1eaf8e6b828fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f40e4cd1c6a25a263c05bd4fbfe8a63"><td class="memTemplParams" colspan="2"><a class="anchor" id="a8f40e4cd1c6a25a263c05bd4fbfe8a63"></a>
template&lt;class ForwardIterator &gt; </td></tr>
<tr class="memitem:a8f40e4cd1c6a25a263c05bd4fbfe8a63"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMoby_1_1CompGeom.html#a8f40e4cd1c6a25a263c05bd4fbfe8a63">is_convex_polygon</a> (ForwardIterator begin, ForwardIterator end, const Ravelin::Vector3d &amp;normal, double tol=NEAR_ZERO)</td></tr>
<tr class="memdesc:a8f40e4cd1c6a25a263c05bd4fbfe8a63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether a polygon (in 3D) is convex. <br/></td></tr>
<tr class="separator:a8f40e4cd1c6a25a263c05bd4fbfe8a63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d1fdfbfa5fee2f3bbea44e22696a9bb"><td class="memTemplParams" colspan="2">template&lt;class ForwardIterator , class OutputIterator &gt; </td></tr>
<tr class="memitem:a6d1fdfbfa5fee2f3bbea44e22696a9bb"><td class="memTemplItemLeft" align="right" valign="top">static OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMoby_1_1CompGeom.html#a6d1fdfbfa5fee2f3bbea44e22696a9bb">calc_convex_hull</a> (ForwardIterator source_begin, ForwardIterator source_end, const Ravelin::Vector3d &amp;normal, OutputIterator target_begin)</td></tr>
<tr class="memdesc:a6d1fdfbfa5fee2f3bbea44e22696a9bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the convex hull of a set of points that lie on a 2D manifold using quickhull.  <a href="#a6d1fdfbfa5fee2f3bbea44e22696a9bb">More...</a><br/></td></tr>
<tr class="separator:a6d1fdfbfa5fee2f3bbea44e22696a9bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8972fb0cb11f9cfb4630a83a8b45f9bc"><td class="memTemplParams" colspan="2">template&lt;class ForwardIterator , class OutputIterator &gt; </td></tr>
<tr class="memitem:a8972fb0cb11f9cfb4630a83a8b45f9bc"><td class="memTemplItemLeft" align="right" valign="top">static OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMoby_1_1CompGeom.html#a8972fb0cb11f9cfb4630a83a8b45f9bc">calc_convex_hull</a> (ForwardIterator source_begin, ForwardIterator source_end, OutputIterator target_begin)</td></tr>
<tr class="memdesc:a8972fb0cb11f9cfb4630a83a8b45f9bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the convex hull of a set of points in 2D using quickhull.  <a href="#a8972fb0cb11f9cfb4630a83a8b45f9bc">More...</a><br/></td></tr>
<tr class="separator:a8972fb0cb11f9cfb4630a83a8b45f9bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a747cb185724f45bc91a227fc555287"><td class="memTemplParams" colspan="2">template&lt;class ForwardIterator &gt; </td></tr>
<tr class="memitem:a8a747cb185724f45bc91a227fc555287"><td class="memTemplItemLeft" align="right" valign="top">static PolygonLocationType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMoby_1_1CompGeom.html#a8a747cb185724f45bc91a227fc555287">polygon_location</a> (ForwardIterator begin, ForwardIterator end, const <a class="el" href="namespaceMoby.html#ad8a5998be346e36d61d73fb858461b58">Point2d</a> &amp;point)</td></tr>
<tr class="memdesc:a8a747cb185724f45bc91a227fc555287"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether a 2D point is inside a polygon.  <a href="#a8a747cb185724f45bc91a227fc555287">More...</a><br/></td></tr>
<tr class="separator:a8a747cb185724f45bc91a227fc555287"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73837ae14eacdde1c00b5c849241479e"><td class="memTemplParams" colspan="2">template&lt;class ForwardIterator &gt; </td></tr>
<tr class="memitem:a73837ae14eacdde1c00b5c849241479e"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="namespaceMoby.html#ad8a5998be346e36d61d73fb858461b58">Point2d</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMoby_1_1CompGeom.html#a73837ae14eacdde1c00b5c849241479e">calc_centroid_2D</a> (ForwardIterator begin, ForwardIterator end)</td></tr>
<tr class="memdesc:a73837ae14eacdde1c00b5c849241479e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the centroid of points on a plane.  <a href="#a73837ae14eacdde1c00b5c849241479e">More...</a><br/></td></tr>
<tr class="separator:a73837ae14eacdde1c00b5c849241479e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a509ee133796072a2c2f44625c05b55f7"><td class="memTemplParams" colspan="2">template&lt;class ForwardIterator &gt; </td></tr>
<tr class="memitem:a509ee133796072a2c2f44625c05b55f7"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="namespaceMoby.html#a846eb82dfba26e708e01316dc47a3e39">Point3d</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMoby_1_1CompGeom.html#a509ee133796072a2c2f44625c05b55f7">calc_centroid_2D</a> (ForwardIterator begin, ForwardIterator end, const Ravelin::Vector3d &amp;normal)</td></tr>
<tr class="memdesc:a509ee133796072a2c2f44625c05b55f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the 3D (2D) centroid of points on a plane.  <a href="#a509ee133796072a2c2f44625c05b55f7">More...</a><br/></td></tr>
<tr class="separator:a509ee133796072a2c2f44625c05b55f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a592deedcb8c946e033b3c84eee7b4e18"><td class="memTemplParams" colspan="2">template&lt;class ForwardIterator &gt; </td></tr>
<tr class="memitem:a592deedcb8c946e033b3c84eee7b4e18"><td class="memTemplItemLeft" align="right" valign="top">static double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMoby_1_1CompGeom.html#a592deedcb8c946e033b3c84eee7b4e18">calc_polygon_area</a> (ForwardIterator begin, ForwardIterator end, const Ravelin::Vector3d &amp;normal)</td></tr>
<tr class="memdesc:a592deedcb8c946e033b3c84eee7b4e18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the area of a polygon in 3D.  <a href="#a592deedcb8c946e033b3c84eee7b4e18">More...</a><br/></td></tr>
<tr class="separator:a592deedcb8c946e033b3c84eee7b4e18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7fcc206f66a3888ddb2c6d7c46d21da"><td class="memTemplParams" colspan="2">template&lt;class ForwardIterator &gt; </td></tr>
<tr class="memitem:aa7fcc206f66a3888ddb2c6d7c46d21da"><td class="memTemplItemLeft" align="right" valign="top">static double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMoby_1_1CompGeom.html#aa7fcc206f66a3888ddb2c6d7c46d21da">calc_polygon_area</a> (ForwardIterator begin, ForwardIterator end)</td></tr>
<tr class="memdesc:aa7fcc206f66a3888ddb2c6d7c46d21da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the area of a polygon in 2D.  <a href="#aa7fcc206f66a3888ddb2c6d7c46d21da">More...</a><br/></td></tr>
<tr class="separator:aa7fcc206f66a3888ddb2c6d7c46d21da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bb1613349c111d5fdd1f200e0c5f516"><td class="memTemplParams" colspan="2">template&lt;class ForwardIterator &gt; </td></tr>
<tr class="memitem:a5bb1613349c111d5fdd1f200e0c5f516"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMoby_1_1CompGeom.html#a5bb1613349c111d5fdd1f200e0c5f516">project_plane</a> (ForwardIterator begin, ForwardIterator end, const Ravelin::Vector3d &amp;normal, double offset)</td></tr>
<tr class="memdesc:a5bb1613349c111d5fdd1f200e0c5f516"><td class="mdescLeft">&#160;</td><td class="mdescRight">Projects a set of points onto a plane.  <a href="#a5bb1613349c111d5fdd1f200e0c5f516">More...</a><br/></td></tr>
<tr class="separator:a5bb1613349c111d5fdd1f200e0c5f516"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a608392fd29f1b8a9ae94ef4422dde8ed"><td class="memTemplParams" colspan="2">template&lt;class ForwardIterator &gt; </td></tr>
<tr class="memitem:a608392fd29f1b8a9ae94ef4422dde8ed"><td class="memTemplItemLeft" align="right" valign="top">static double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMoby_1_1CompGeom.html#a608392fd29f1b8a9ae94ef4422dde8ed">fit_plane</a> (ForwardIterator begin, ForwardIterator end, Ravelin::Vector3d &amp;normal, double &amp;offset)</td></tr>
<tr class="memdesc:a608392fd29f1b8a9ae94ef4422dde8ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to fit a plane to a set of points.  <a href="#a608392fd29f1b8a9ae94ef4422dde8ed">More...</a><br/></td></tr>
<tr class="separator:a608392fd29f1b8a9ae94ef4422dde8ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e37a986917fca0b8a38fffd559b206f"><td class="memTemplParams" colspan="2">template&lt;class ForwardIterator , class OutputIterator &gt; </td></tr>
<tr class="memitem:a8e37a986917fca0b8a38fffd559b206f"><td class="memTemplItemLeft" align="right" valign="top">static OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMoby_1_1CompGeom.html#a8e37a986917fca0b8a38fffd559b206f">triangulate_convex_polygon</a> (ForwardIterator source_begin, ForwardIterator source_end, OutputIterator target_begin)</td></tr>
<tr class="memdesc:a8e37a986917fca0b8a38fffd559b206f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Triangulates a convex polygon in O(n)  <a href="#a8e37a986917fca0b8a38fffd559b206f">More...</a><br/></td></tr>
<tr class="separator:a8e37a986917fca0b8a38fffd559b206f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79f90f64a73d5111201fb2b624e8f779"><td class="memTemplParams" colspan="2">template&lt;class OutputIterator &gt; </td></tr>
<tr class="memitem:a79f90f64a73d5111201fb2b624e8f779"><td class="memTemplItemLeft" align="right" valign="top">static OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMoby_1_1CompGeom.html#a79f90f64a73d5111201fb2b624e8f779">intersect_tris</a> (const <a class="el" href="classMoby_1_1Triangle.html">Triangle</a> &amp;t1, const <a class="el" href="classMoby_1_1Triangle.html">Triangle</a> &amp;t2, OutputIterator begin)</td></tr>
<tr class="memdesc:a79f90f64a73d5111201fb2b624e8f779"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intersects two triangles in 3D and returns the points of intersection.  <a href="#a79f90f64a73d5111201fb2b624e8f779">More...</a><br/></td></tr>
<tr class="separator:a79f90f64a73d5111201fb2b624e8f779"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9e08a7ade06867db6636a7f68375af0"><td class="memTemplParams" colspan="2">template&lt;class OutputIterator &gt; </td></tr>
<tr class="memitem:af9e08a7ade06867db6636a7f68375af0"><td class="memTemplItemLeft" align="right" valign="top">static OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMoby_1_1CompGeom.html#af9e08a7ade06867db6636a7f68375af0">intersect_coplanar_tris</a> (const <a class="el" href="classMoby_1_1Triangle.html">Triangle</a> &amp;t1, const <a class="el" href="classMoby_1_1Triangle.html">Triangle</a> &amp;t2, const Ravelin::Vector3d &amp;normal, OutputIterator begin)</td></tr>
<tr class="memdesc:af9e08a7ade06867db6636a7f68375af0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intersects two coplanar triangles.  <a href="#af9e08a7ade06867db6636a7f68375af0">More...</a><br/></td></tr>
<tr class="separator:af9e08a7ade06867db6636a7f68375af0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac799f5a36a9ff677f8bd5a0f9c65269a"><td class="memTemplParams" colspan="2">template&lt;class ForwardIterator , class OutputIterator &gt; </td></tr>
<tr class="memitem:ac799f5a36a9ff677f8bd5a0f9c65269a"><td class="memTemplItemLeft" align="right" valign="top">static OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMoby_1_1CompGeom.html#ac799f5a36a9ff677f8bd5a0f9c65269a">to_2D</a> (ForwardIterator begin, ForwardIterator end, const Ravelin::Matrix3d &amp;R, OutputIterator begin_target)</td></tr>
<tr class="separator:ac799f5a36a9ff677f8bd5a0f9c65269a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b1a0f6f816a5b0b7aa506d2f0a04d72"><td class="memTemplParams" colspan="2">template&lt;class ForwardIterator , class OutputIterator &gt; </td></tr>
<tr class="memitem:a2b1a0f6f816a5b0b7aa506d2f0a04d72"><td class="memTemplItemLeft" align="right" valign="top">static OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMoby_1_1CompGeom.html#a2b1a0f6f816a5b0b7aa506d2f0a04d72">to_3D</a> (ForwardIterator begin, ForwardIterator end, OutputIterator begin_target, const Ravelin::Matrix3d &amp;RT, double offset)</td></tr>
<tr class="separator:a2b1a0f6f816a5b0b7aa506d2f0a04d72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bdff8fb5024a463973d9bbe5ab3e04a"><td class="memTemplParams" colspan="2">template&lt;class ForwardIterator &gt; </td></tr>
<tr class="memitem:a8bdff8fb5024a463973d9bbe5ab3e04a"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMoby_1_1CompGeom.html#a8bdff8fb5024a463973d9bbe5ab3e04a">determine_seg_endpoints</a> (ForwardIterator begin, ForwardIterator end, std::pair&lt; <a class="el" href="namespaceMoby.html#a846eb82dfba26e708e01316dc47a3e39">Point3d</a>, <a class="el" href="namespaceMoby.html#a846eb82dfba26e708e01316dc47a3e39">Point3d</a> &gt; &amp;endpoints)</td></tr>
<tr class="memdesc:a8bdff8fb5024a463973d9bbe5ab3e04a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the endpoints for a container of collinear Ravelin::Vector3d objects.  <a href="#a8bdff8fb5024a463973d9bbe5ab3e04a">More...</a><br/></td></tr>
<tr class="separator:a8bdff8fb5024a463973d9bbe5ab3e04a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22097b53c6e87ff29ed42bbbdabc8478"><td class="memTemplParams" colspan="2">template&lt;class ForwardIterator &gt; </td></tr>
<tr class="memitem:a22097b53c6e87ff29ed42bbbdabc8478"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMoby_1_1CompGeom.html#a22097b53c6e87ff29ed42bbbdabc8478">determine_seg_endpoints</a> (ForwardIterator begin, ForwardIterator end, std::pair&lt; <a class="el" href="namespaceMoby.html#a846eb82dfba26e708e01316dc47a3e39">Point3d</a> *, <a class="el" href="namespaceMoby.html#a846eb82dfba26e708e01316dc47a3e39">Point3d</a> * &gt; &amp;endpoints)</td></tr>
<tr class="memdesc:a22097b53c6e87ff29ed42bbbdabc8478"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the endpoints for a container of collinear Ravelin::Vector3d objects.  <a href="#a22097b53c6e87ff29ed42bbbdabc8478">More...</a><br/></td></tr>
<tr class="separator:a22097b53c6e87ff29ed42bbbdabc8478"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8998c302ec5a93179f153711866cae73"><td class="memTemplParams" colspan="2">template&lt;class ForwardIterator &gt; </td></tr>
<tr class="memitem:a8998c302ec5a93179f153711866cae73"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMoby_1_1CompGeom.html#a8998c302ec5a93179f153711866cae73">determine_seg_endpoints</a> (ForwardIterator begin, ForwardIterator end, std::pair&lt; <a class="el" href="namespaceMoby.html#ad8a5998be346e36d61d73fb858461b58">Point2d</a>, <a class="el" href="namespaceMoby.html#ad8a5998be346e36d61d73fb858461b58">Point2d</a> &gt; &amp;endpoints)</td></tr>
<tr class="memdesc:a8998c302ec5a93179f153711866cae73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the endpoints for a container of collinear Point2d objects.  <a href="#a8998c302ec5a93179f153711866cae73">More...</a><br/></td></tr>
<tr class="separator:a8998c302ec5a93179f153711866cae73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f3043f986e07262c02dba6be84170e6"><td class="memTemplParams" colspan="2">template&lt;class ForwardIterator &gt; </td></tr>
<tr class="memitem:a6f3043f986e07262c02dba6be84170e6"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMoby_1_1CompGeom.html#a6f3043f986e07262c02dba6be84170e6">determine_seg_endpoints</a> (ForwardIterator begin, ForwardIterator end, std::pair&lt; <a class="el" href="namespaceMoby.html#ad8a5998be346e36d61d73fb858461b58">Point2d</a> *, <a class="el" href="namespaceMoby.html#ad8a5998be346e36d61d73fb858461b58">Point2d</a> * &gt; &amp;endpoints)</td></tr>
<tr class="memdesc:a6f3043f986e07262c02dba6be84170e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the endpoints for a container of collinear Point2d* objects.  <a href="#a6f3043f986e07262c02dba6be84170e6">More...</a><br/></td></tr>
<tr class="separator:a6f3043f986e07262c02dba6be84170e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa631bbdb5504678d2d844735002cca6"><td class="memTemplParams" colspan="2">template&lt;class ForwardIterator &gt; </td></tr>
<tr class="memitem:afa631bbdb5504678d2d844735002cca6"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="namespaceMoby.html#addf6a9597fd5786651d804e5aef9a4c6">TessellatedPolyhedronPtr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMoby_1_1CompGeom.html#afa631bbdb5504678d2d844735002cca6">calc_convex_hull</a> (ForwardIterator first, ForwardIterator last)</td></tr>
<tr class="memdesc:afa631bbdb5504678d2d844735002cca6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the 3D convex hull of a set of points.  <a href="#afa631bbdb5504678d2d844735002cca6">More...</a><br/></td></tr>
<tr class="separator:afa631bbdb5504678d2d844735002cca6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ede08dd68d71081f5bd1d6ade4e0b85"><td class="memTemplParams" colspan="2">template&lt;class ForwardIterator &gt; </td></tr>
<tr class="memitem:a3ede08dd68d71081f5bd1d6ade4e0b85"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="namespaceMoby.html#a846eb82dfba26e708e01316dc47a3e39">Point3d</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMoby_1_1CompGeom.html#a3ede08dd68d71081f5bd1d6ade4e0b85">calc_centroid_3D</a> (ForwardIterator first, ForwardIterator last)</td></tr>
<tr class="memdesc:a3ede08dd68d71081f5bd1d6ade4e0b85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the centroid of a set of facets.  <a href="#a3ede08dd68d71081f5bd1d6ade4e0b85">More...</a><br/></td></tr>
<tr class="separator:a3ede08dd68d71081f5bd1d6ade4e0b85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fc3346ba45a1cc96ab7781ec732106e"><td class="memTemplParams" colspan="2">template&lt;class ForwardIterator &gt; </td></tr>
<tr class="memitem:a0fc3346ba45a1cc96ab7781ec732106e"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="namespaceMoby.html#addf6a9597fd5786651d804e5aef9a4c6">TessellatedPolyhedronPtr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMoby_1_1CompGeom.html#a0fc3346ba45a1cc96ab7781ec732106e">calc_hs_intersection</a> (ForwardIterator start, ForwardIterator end, const Ravelin::Origin3d &amp;interior_point)</td></tr>
<tr class="memdesc:a0fc3346ba45a1cc96ab7781ec732106e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the halfspace intersection, returning the result as a convex polyhedron.  <a href="#a0fc3346ba45a1cc96ab7781ec732106e">More...</a><br/></td></tr>
<tr class="separator:a0fc3346ba45a1cc96ab7781ec732106e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a4c756ab335e006ef110377beeadd2e"><td class="memTemplParams" colspan="2">template&lt;class ForwardIterator &gt; </td></tr>
<tr class="memitem:a3a4c756ab335e006ef110377beeadd2e"><td class="memTemplItemLeft" align="right" valign="top">static double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMoby_1_1CompGeom.html#a3a4c756ab335e006ef110377beeadd2e">find_hs_interior_point</a> (ForwardIterator start, ForwardIterator end, Ravelin::Origin3d &amp;point)</td></tr>
<tr class="memdesc:a3a4c756ab335e006ef110377beeadd2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds an interior point of a set of halfspaces using linear programming.  <a href="#a3a4c756ab335e006ef110377beeadd2e">More...</a><br/></td></tr>
<tr class="separator:a3a4c756ab335e006ef110377beeadd2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a58933c8623c46d805e194d48be6442"><td class="memTemplParams" colspan="2"><a class="anchor" id="a2a58933c8623c46d805e194d48be6442"></a>
template&lt;class ForwardIterator &gt; </td></tr>
<tr class="memitem:a2a58933c8623c46d805e194d48be6442"><td class="memTemplItemLeft" align="right" valign="top">static unsigned&#160;</td><td class="memTemplItemRight" valign="bottom"><b>calc_dimensionality</b> (ForwardIterator first, ForwardIterator last, double tol=NEAR_ZERO)</td></tr>
<tr class="separator:a2a58933c8623c46d805e194d48be6442"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38094974cb3fa7c43811bd8a8e07f53f"><td class="memTemplParams" colspan="2">template&lt;class ForwardIterator &gt; </td></tr>
<tr class="memitem:a38094974cb3fa7c43811bd8a8e07f53f"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMoby_1_1CompGeom.html#a38094974cb3fa7c43811bd8a8e07f53f">intersect_seg_convex_polygon</a> (ForwardIterator begin, ForwardIterator end, const <a class="el" href="namespaceMoby.html#ac1e78acf3c1ee806a04bb6d35eadcf46">LineSeg2</a> &amp;seg, double &amp;te, double &amp;tl, double tol=NEAR_ZERO)</td></tr>
<tr class="memdesc:a38094974cb3fa7c43811bd8a8e07f53f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the intersection of a convex polygon and a line segment.  <a href="#a38094974cb3fa7c43811bd8a8e07f53f">More...</a><br/></td></tr>
<tr class="separator:a38094974cb3fa7c43811bd8a8e07f53f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a523384bf1a484781696fea303fb54d92"><td class="memTemplParams" colspan="2">template&lt;class ForwardIterator , class OutputIterator &gt; </td></tr>
<tr class="memitem:a523384bf1a484781696fea303fb54d92"><td class="memTemplItemLeft" align="right" valign="top">static OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMoby_1_1CompGeom.html#a523384bf1a484781696fea303fb54d92">intersect_seg_polygon</a> (ForwardIterator begin, ForwardIterator end, const <a class="el" href="namespaceMoby.html#ac1e78acf3c1ee806a04bb6d35eadcf46">LineSeg2</a> &amp;seg, OutputIterator outbegin)</td></tr>
<tr class="memdesc:a523384bf1a484781696fea303fb54d92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the intersection of a polygon and a line segment.  <a href="#a523384bf1a484781696fea303fb54d92">More...</a><br/></td></tr>
<tr class="separator:a523384bf1a484781696fea303fb54d92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5841bb99e1471e9416786db68b8b6d9f"><td class="memTemplParams" colspan="2">template&lt;class BidirectionalIterator , class OutputIterator &gt; </td></tr>
<tr class="memitem:a5841bb99e1471e9416786db68b8b6d9f"><td class="memTemplItemLeft" align="right" valign="top">static OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMoby_1_1CompGeom.html#a5841bb99e1471e9416786db68b8b6d9f">triangulate_polygon_2D</a> (BidirectionalIterator begin, BidirectionalIterator end, OutputIterator begintarget, double tol=NEAR_ZERO)</td></tr>
<tr class="memdesc:a5841bb99e1471e9416786db68b8b6d9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Triangulates a polygon (in 2D)  <a href="#a5841bb99e1471e9416786db68b8b6d9f">More...</a><br/></td></tr>
<tr class="separator:a5841bb99e1471e9416786db68b8b6d9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06cb843226380d401d3831dd6d1185f8"><td class="memTemplParams" colspan="2"><a class="anchor" id="a06cb843226380d401d3831dd6d1185f8"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a06cb843226380d401d3831dd6d1185f8"><td class="memTemplItemLeft" align="right" valign="top">static T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMoby_1_1CompGeom.html#a06cb843226380d401d3831dd6d1185f8">point_on_seg</a> (T a, T b, double t)</td></tr>
<tr class="memdesc:a06cb843226380d401d3831dd6d1185f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the point a*t + (1-t)*b on the line segment ab. <br/></td></tr>
<tr class="separator:a06cb843226380d401d3831dd6d1185f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a28d1b9582890ca3e2b61dafdc1c3ba84"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a28d1b9582890ca3e2b61dafdc1c3ba84"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>Polyhedron</b></td></tr>
<tr class="separator:a28d1b9582890ca3e2b61dafdc1c3ba84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9832ce28e3a1f8799f685535d315cea"><td class="memTemplParams" colspan="2"><a class="anchor" id="ad9832ce28e3a1f8799f685535d315cea"></a>
template&lt;class T , class V &gt; </td></tr>
<tr class="memitem:ad9832ce28e3a1f8799f685535d315cea"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><b>CompGeomSpecOne</b></td></tr>
<tr class="separator:ad9832ce28e3a1f8799f685535d315cea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76799154fc4695d24286bbd8d3129faf"><td class="memTemplParams" colspan="2"><a class="anchor" id="a76799154fc4695d24286bbd8d3129faf"></a>
template&lt;class T , class U , class V &gt; </td></tr>
<tr class="memitem:a76799154fc4695d24286bbd8d3129faf"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><b>CompGeomSpecTwo</b></td></tr>
<tr class="separator:a76799154fc4695d24286bbd8d3129faf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Class for performing assorted computational geometry functions. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a22d8b75e9a271b21feb44f9b2a49fafb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class OutputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned Moby::CompGeom::advance </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned *&#160;</td>
          <td class="paramname"><em>aa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>inside</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceMoby.html#ad8a5998be346e36d61d73fb858461b58">Point2d</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator &amp;&#160;</td>
          <td class="paramname"><em>current</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Utility function for <a class="el" href="classMoby_1_1CompGeom.html#af9e08a7ade06867db6636a7f68375af0" title="Intersects two coplanar triangles. ">intersect_coplanar_tris()</a> </p>
<p>Taken from O'Rourke, p. 259. </p>

</div>
</div>
<a class="anchor" id="a73837ae14eacdde1c00b5c849241479e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ForwardIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceMoby.html#ad8a5998be346e36d61d73fb858461b58">Point2d</a> Moby::CompGeom::calc_centroid_2D </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the centroid of points on a plane. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>an iterator to a polygon in 2D </td></tr>
    <tr><td class="paramname">end</td><td>an iterator to a polygon in 2D </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a509ee133796072a2c2f44625c05b55f7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ForwardIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceMoby.html#a846eb82dfba26e708e01316dc47a3e39">Point3d</a> Moby::CompGeom::calc_centroid_2D </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Ravelin::Vector3d &amp;&#160;</td>
          <td class="paramname"><em>normal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the 3D (2D) centroid of points on a plane. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poly</td><td>a counter-clockwise oriented polygon in 3D </td></tr>
    <tr><td class="paramname">normal</td><td>a vector normal to the plane that contains the points </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a73837ae14eacdde1c00b5c849241479e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ForwardIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceMoby.html#ad8a5998be346e36d61d73fb858461b58">Point2d</a> Moby::CompGeom::calc_centroid_2D </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the centroid of points on a plane. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>an iterator to a polygon in 2D </td></tr>
    <tr><td class="paramname">end</td><td>an iterator to a polygon in 2D </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a509ee133796072a2c2f44625c05b55f7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ForwardIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceMoby.html#a846eb82dfba26e708e01316dc47a3e39">Point3d</a> Moby::CompGeom::calc_centroid_2D </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Ravelin::Vector3d &amp;&#160;</td>
          <td class="paramname"><em>normal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the 3D (2D) centroid of points on a plane. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poly</td><td>a counter-clockwise oriented polygon in 3D </td></tr>
    <tr><td class="paramname">normal</td><td>a vector normal to the plane that contains the points </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3ede08dd68d71081f5bd1d6ade4e0b85"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ForwardIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceMoby.html#a846eb82dfba26e708e01316dc47a3e39">Point3d</a> Moby::CompGeom::calc_centroid_3D </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the centroid of a set of facets. </p>
<p>The facets may represent a polygon, a polyhedron, or even an open polyhedron. However, the facets may not intersect. </p>

</div>
</div>
<a class="anchor" id="a3ede08dd68d71081f5bd1d6ade4e0b85"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ForwardIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceMoby.html#a846eb82dfba26e708e01316dc47a3e39">Point3d</a> Moby::CompGeom::calc_centroid_3D </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the centroid of a set of facets. </p>
<p>The facets may represent a polygon, a polyhedron, or even an open polyhedron. However, the facets may not intersect. </p>

</div>
</div>
<a class="anchor" id="af37c5dc89a0c39b1a62bd4241223f6dd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double CompGeom::calc_closest_points </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceMoby.html#ad691671b09efaee22f1758f1a1c3b2de">LineSeg3</a> &amp;&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceMoby.html#ad691671b09efaee22f1758f1a1c3b2de">LineSeg3</a> &amp;&#160;</td>
          <td class="paramname"><em>s2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMoby.html#a846eb82dfba26e708e01316dc47a3e39">Point3d</a> &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMoby.html#a846eb82dfba26e708e01316dc47a3e39">Point3d</a> &amp;&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the shortest line segment between two line segments in 3D. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s1</td><td>the first segment </td></tr>
    <tr><td class="paramname">s2</td><td>the second segment </td></tr>
    <tr><td class="paramname">p1</td><td>the closest point on s1 to s2 (on return) </td></tr>
    <tr><td class="paramname">p2</td><td>the closest point on s2 to s1 (on return) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the distance between p1 and p2 </dd></dl>
<dl class="section note"><dt>Note</dt><dd>algorithm taken from <a href="http://geometricalgorithms.com">http://geometricalgorithms.com</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a6d1fdfbfa5fee2f3bbea44e22696a9bb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ForwardIterator , class OutputIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">OutputIterator Moby::CompGeom::calc_convex_hull </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>source_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>source_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Ravelin::Vector3d &amp;&#160;</td>
          <td class="paramname"><em>normal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>target_begin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the convex hull of a set of points that lie on a 2D manifold using quickhull. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source_begin</td><td>an iterator to the beginning of a container of points </td></tr>
    <tr><td class="paramname">source_end</td><td>an iterator pointing to the end of a container of points </td></tr>
    <tr><td class="paramname">normal</td><td>the (optional) normal of the points; this will be computed if normal is zero vector </td></tr>
    <tr><td class="paramname">target_begin</td><td>an iterator to the beginning of a container of points; on return, contains the convex hull (NOTE: size of this container must be as large as the source container) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the new end of the target container </dd></dl>

<p>Referenced by <a class="el" href="classMoby_1_1CylinderPrimitive.html#a2b31ce48bfc4a622b61b02691776f7ec">Moby::CylinderPrimitive::get_mesh()</a>, <a class="el" href="classMoby_1_1SpherePrimitive.html#aaa9cef7360a44370f5c918efb9ee6f31">Moby::SpherePrimitive::get_mesh()</a>, <a class="el" href="classMoby_1_1ConePrimitive.html#a21873b1161a88b316087413075913d22">Moby::ConePrimitive::get_mesh()</a>, and <a class="el" href="classMoby_1_1TriangleMeshPrimitive.html#a0bda568457bc891164862cdddf79e5bd">Moby::TriangleMeshPrimitive::set_mesh()</a>.</p>

</div>
</div>
<a class="anchor" id="a8972fb0cb11f9cfb4630a83a8b45f9bc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ForwardIterator , class OutputIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">OutputIterator Moby::CompGeom::calc_convex_hull </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>source_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>source_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>target_begin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the convex hull of a set of points in 2D using quickhull. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source_begin</td><td>an iterator to the beginning of a container of Point2d or Point2d* </td></tr>
    <tr><td class="paramname">source_end</td><td>an iterator pointing to the end of a container of Point2d or Point2d* </td></tr>
    <tr><td class="paramname">target_begin</td><td>an iterator to the beginning of a container of indices; on return, contains the convex hull (NOTE: size of this container must be as large as the source container) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the new end of the target container </dd></dl>

</div>
</div>
<a class="anchor" id="afa631bbdb5504678d2d844735002cca6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ForwardIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceMoby.html#addf6a9597fd5786651d804e5aef9a4c6">TessellatedPolyhedronPtr</a> Moby::CompGeom::calc_convex_hull </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the 3D convex hull of a set of points. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>a forward iterator for type Ravelin::Vector3 </td></tr>
    <tr><td class="paramname">last</td><td>a forward iterator for type Ravelin::Vector3 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the newly created polyhedron </dd></dl>

</div>
</div>
<a class="anchor" id="afa631bbdb5504678d2d844735002cca6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ForwardIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceMoby.html#addf6a9597fd5786651d804e5aef9a4c6">TessellatedPolyhedronPtr</a> Moby::CompGeom::calc_convex_hull </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the 3D convex hull of a set of points. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>a forward iterator for type Ravelin::Vector3 </td></tr>
    <tr><td class="paramname">last</td><td>a forward iterator for type Ravelin::Vector3 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the newly created polyhedron </dd></dl>

</div>
</div>
<a class="anchor" id="a8972fb0cb11f9cfb4630a83a8b45f9bc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ForwardIterator , class OutputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OutputIterator Moby::CompGeom::calc_convex_hull </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>source_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>source_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>target_begin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the convex hull of a set of points in 2D using quickhull. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source_begin</td><td>an iterator to the beginning of a container of Point2d or Point2d* </td></tr>
    <tr><td class="paramname">source_end</td><td>an iterator pointing to the end of a container of Point2d or Point2d* </td></tr>
    <tr><td class="paramname">target_begin</td><td>an iterator to the beginning of a container of indices; on return, contains the convex hull (NOTE: size of this container must be as large as the source container) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the new end of the target container </dd></dl>

</div>
</div>
<a class="anchor" id="a6d1fdfbfa5fee2f3bbea44e22696a9bb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ForwardIterator , class OutputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OutputIterator Moby::CompGeom::calc_convex_hull </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>source_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>source_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Ravelin::Vector3d &amp;&#160;</td>
          <td class="paramname"><em>normal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>target_begin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the convex hull of a set of points that lie on a 2D manifold using quickhull. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source_begin</td><td>an iterator to the beginning of a container of points </td></tr>
    <tr><td class="paramname">source_end</td><td>an iterator pointing to the end of a container of points </td></tr>
    <tr><td class="paramname">normal</td><td>the (optional) normal of the points; this will be computed if normal is zero vector </td></tr>
    <tr><td class="paramname">target_begin</td><td>an iterator to the beginning of a container of points; on return, contains the convex hull (NOTE: size of this container must be as large as the source container) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the new end of the target container </dd></dl>

</div>
</div>
<a class="anchor" id="a1c3708070d96e4e756cc725a9633c0a6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double CompGeom::calc_dist </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceMoby.html#ad691671b09efaee22f1758f1a1c3b2de">LineSeg3</a> &amp;&#160;</td>
          <td class="paramname"><em>line_seg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceMoby.html#a846eb82dfba26e708e01316dc47a3e39">Point3d</a> &amp;&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMoby.html#a846eb82dfba26e708e01316dc47a3e39">Point3d</a> &amp;&#160;</td>
          <td class="paramname"><em>closest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the Euclidean distance between a line segment and a point in 3D. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">line_seg</td><td>the two endpoints of the line segment </td></tr>
    <tr><td class="paramname">point</td><td>the query point </td></tr>
    <tr><td class="paramname">t</td><td>gives the parametric form line_seg.first + (line_seg.second - line_seg.first) * t </td></tr>
    <tr><td class="paramname">closest</td><td>point on the line segment to point </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0fc3346ba45a1cc96ab7781ec732106e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ForwardIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceMoby.html#addf6a9597fd5786651d804e5aef9a4c6">TessellatedPolyhedronPtr</a> Moby::CompGeom::calc_hs_intersection </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Ravelin::Origin3d &amp;&#160;</td>
          <td class="paramname"><em>interior_point</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the halfspace intersection, returning the result as a convex polyhedron. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start</td><td>an iterator to the start of a collection of halfspaces, each of type std::pair&lt;Ravelin::Vector3, double&gt;, where the vector [nx ny nz] is the normal to the halfspace and the scalar is the offset 'd'; each halfspace will satisfy the equation nx*x + ny*y + nz*z &lt;= d </td></tr>
    <tr><td class="paramname">end</td><td>an iterator to the end of the collection </td></tr>
    <tr><td class="paramname">interior_point</td><td>a point interior to all of the halfspaces </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the created polyhedron or a NULL pointer if unsuccessful </dd></dl>

</div>
</div>
<a class="anchor" id="a0fc3346ba45a1cc96ab7781ec732106e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ForwardIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceMoby.html#addf6a9597fd5786651d804e5aef9a4c6">TessellatedPolyhedronPtr</a> Moby::CompGeom::calc_hs_intersection </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Ravelin::Origin3d &amp;&#160;</td>
          <td class="paramname"><em>interior_point</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the halfspace intersection, returning the result as a convex polyhedron. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start</td><td>an iterator to the start of a collection of halfspaces, each of type std::pair&lt;Ravelin::Vector3, double&gt;, where the vector [nx ny nz] is the normal to the halfspace and the scalar is the offset 'd'; each halfspace will satisfy the equation nx*x + ny*y + nz*z &lt;= d </td></tr>
    <tr><td class="paramname">end</td><td>an iterator to the end of the collection </td></tr>
    <tr><td class="paramname">interior_point</td><td>a point interior to all of the halfspaces </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the created polyhedron or a NULL pointer if unsuccessful </dd></dl>

</div>
</div>
<a class="anchor" id="a00516ed14bbe6b3d5d73273313f03e9c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ForwardIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Moby::CompGeom::calc_min_area_bounding_rect </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMoby.html#ad8a5998be346e36d61d73fb858461b58">Point2d</a> &amp;&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMoby.html#ad8a5998be346e36d61d73fb858461b58">Point2d</a> &amp;&#160;</td>
          <td class="paramname"><em>x2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMoby.html#ad8a5998be346e36d61d73fb858461b58">Point2d</a> &amp;&#160;</td>
          <td class="paramname"><em>x3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMoby.html#ad8a5998be346e36d61d73fb858461b58">Point2d</a> &amp;&#160;</td>
          <td class="paramname"><em>x4</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the minimum area bounding rectangle of a set of points. </p>
<p>Uses 2D convex hull and rotating calipers method; runs in O(N lg N) time On return, x1, x2, x3, and x4 are the four vertices of the bounding rectangle (ordered as edges). </p>

</div>
</div>
<a class="anchor" id="a1030878667a2a4c9ba268fa653ee9121"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ForwardIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Moby::CompGeom::calc_min_area_bounding_rect </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMoby.html#ad8a5998be346e36d61d73fb858461b58">Point2d</a> &amp;&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMoby.html#ad8a5998be346e36d61d73fb858461b58">Point2d</a> &amp;&#160;</td>
          <td class="paramname"><em>x2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMoby.html#ad8a5998be346e36d61d73fb858461b58">Point2d</a> &amp;&#160;</td>
          <td class="paramname"><em>x3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMoby.html#ad8a5998be346e36d61d73fb858461b58">Point2d</a> &amp;&#160;</td>
          <td class="paramname"><em>x4</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the minimum area bounding rectangle of a set of points. </p>
<p>Uses 2D convex hull and rotating calipers method; runs in O(N lg N) time On return, x1, x2, x3, and x4 are the four vertices of the bounding rectangle (ordered as edges). </p>

</div>
</div>
<a class="anchor" id="a592deedcb8c946e033b3c84eee7b4e18"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ForwardIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double Moby::CompGeom::calc_polygon_area </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Ravelin::Vector3d &amp;&#160;</td>
          <td class="paramname"><em>normal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the area of a polygon in 3D. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poly</td><td>a counter-clockwise oriented polygon in 3D </td></tr>
    <tr><td class="paramname">normal</td><td>a vector normal to the plane that contains the points </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa7fcc206f66a3888ddb2c6d7c46d21da"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ForwardIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double Moby::CompGeom::calc_polygon_area </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the area of a polygon in 2D. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poly</td><td>a counter-clockwise oriented polygon in 2D </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa7fcc206f66a3888ddb2c6d7c46d21da"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ForwardIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double Moby::CompGeom::calc_polygon_area </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the area of a polygon in 2D. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poly</td><td>a counter-clockwise oriented polygon in 2D </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a592deedcb8c946e033b3c84eee7b4e18"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ForwardIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double Moby::CompGeom::calc_polygon_area </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Ravelin::Vector3d &amp;&#160;</td>
          <td class="paramname"><em>normal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the area of a polygon in 3D. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poly</td><td>a counter-clockwise oriented polygon in 3D </td></tr>
    <tr><td class="paramname">normal</td><td>a vector normal to the plane that contains the points </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7f5ad993e3f75a893f69bc4261616dfa"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ForwardIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Moby::CompGeom::ccw </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Ravelin::Vector3d &amp;&#160;</td>
          <td class="paramname"><em>normal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tol</em> = <code>NEAR_ZERO</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Determines whether a polygon in 2D is counter-clockwise </p>
<dl class="section note"><dt>Note</dt><dd>Degenerate polygons (alternating representation) will fail! </dd></dl>

</div>
</div>
<a class="anchor" id="a742c33a9b4ca93a3ee341d271e8e7762"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ForwardIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Moby::CompGeom::ccw </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tol</em> = <code>NEAR_ZERO</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Determines whether a polygon in 2D is counter-clockwise </p>
<dl class="section note"><dt>Note</dt><dd>Degenerate polygons (alternating representation) will fail! </dd></dl>

</div>
</div>
<a class="anchor" id="a2f8be3ca00f0e286d61a978bc6bec573"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ForwardIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool Moby::CompGeom::ccw </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Determines whether a polygon in 2D is counter-clockwise </p>
<dl class="section note"><dt>Note</dt><dd>Degenerate polygons (alternating representation) will fail! </dd></dl>

</div>
</div>
<a class="anchor" id="a31d412921ddd9f15f0d5bfa889ef2ce8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ForwardIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool Moby::CompGeom::ccw </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Ravelin::Vector3d &amp;&#160;</td>
          <td class="paramname"><em>normal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Determines whether a polygon in 2D is counter-clockwise </p>
<dl class="section note"><dt>Note</dt><dd>Degenerate polygons (alternating representation) will fail! </dd></dl>

</div>
</div>
<a class="anchor" id="a8bdff8fb5024a463973d9bbe5ab3e04a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ForwardIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Moby::CompGeom::determine_seg_endpoints </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::pair&lt; <a class="el" href="namespaceMoby.html#a846eb82dfba26e708e01316dc47a3e39">Point3d</a>, <a class="el" href="namespaceMoby.html#a846eb82dfba26e708e01316dc47a3e39">Point3d</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>endpoints</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines the endpoints for a container of collinear Ravelin::Vector3d objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>iterator to beginning of container of type Ravelin::Vector3 </td></tr>
    <tr><td class="paramname">end</td><td>iterator to end of container of type Ravelin::Vector3 </td></tr>
    <tr><td class="paramname">endpoints</td><td>the two farthest points on the segment on return </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a22097b53c6e87ff29ed42bbbdabc8478"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ForwardIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Moby::CompGeom::determine_seg_endpoints </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::pair&lt; <a class="el" href="namespaceMoby.html#a846eb82dfba26e708e01316dc47a3e39">Point3d</a> *, <a class="el" href="namespaceMoby.html#a846eb82dfba26e708e01316dc47a3e39">Point3d</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>endpoints</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines the endpoints for a container of collinear Ravelin::Vector3d objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>iterator to beginning of container of type Ravelin::Vector3 </td></tr>
    <tr><td class="paramname">end</td><td>iterator to end of container of type Ravelin::Vector3 </td></tr>
    <tr><td class="paramname">endpoints</td><td>the two farthest points on the segment on return </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8998c302ec5a93179f153711866cae73"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ForwardIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Moby::CompGeom::determine_seg_endpoints </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::pair&lt; <a class="el" href="namespaceMoby.html#ad8a5998be346e36d61d73fb858461b58">Point2d</a>, <a class="el" href="namespaceMoby.html#ad8a5998be346e36d61d73fb858461b58">Point2d</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>endpoints</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines the endpoints for a container of collinear Point2d objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>iterator to beginning of container of type Point2d </td></tr>
    <tr><td class="paramname">end</td><td>iterator to end of container of type Point2d </td></tr>
    <tr><td class="paramname">endpoints</td><td>the two farthest points on the segment on return </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6f3043f986e07262c02dba6be84170e6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ForwardIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Moby::CompGeom::determine_seg_endpoints </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::pair&lt; <a class="el" href="namespaceMoby.html#ad8a5998be346e36d61d73fb858461b58">Point2d</a> *, <a class="el" href="namespaceMoby.html#ad8a5998be346e36d61d73fb858461b58">Point2d</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>endpoints</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines the endpoints for a container of collinear Point2d* objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>iterator to beginning of container of type Point2d* </td></tr>
    <tr><td class="paramname">end</td><td>iterator to end of container of type Point2d* </td></tr>
    <tr><td class="paramname">endpoints</td><td>the two farthest points on the segment on return </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a22097b53c6e87ff29ed42bbbdabc8478"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ForwardIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Moby::CompGeom::determine_seg_endpoints </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::pair&lt; <a class="el" href="namespaceMoby.html#a846eb82dfba26e708e01316dc47a3e39">Point3d</a> *, <a class="el" href="namespaceMoby.html#a846eb82dfba26e708e01316dc47a3e39">Point3d</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>endpoints</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines the endpoints for a container of collinear Ravelin::Vector3d objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>iterator to beginning of container of type Ravelin::Vector3 </td></tr>
    <tr><td class="paramname">end</td><td>iterator to end of container of type Ravelin::Vector3 </td></tr>
    <tr><td class="paramname">endpoints</td><td>the two farthest points on the segment on return </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8bdff8fb5024a463973d9bbe5ab3e04a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ForwardIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Moby::CompGeom::determine_seg_endpoints </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::pair&lt; <a class="el" href="namespaceMoby.html#a846eb82dfba26e708e01316dc47a3e39">Point3d</a>, <a class="el" href="namespaceMoby.html#a846eb82dfba26e708e01316dc47a3e39">Point3d</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>endpoints</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines the endpoints for a container of collinear Ravelin::Vector3d objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>iterator to beginning of container of type Ravelin::Vector3 </td></tr>
    <tr><td class="paramname">end</td><td>iterator to end of container of type Ravelin::Vector3 </td></tr>
    <tr><td class="paramname">endpoints</td><td>the two farthest points on the segment on return </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8998c302ec5a93179f153711866cae73"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ForwardIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Moby::CompGeom::determine_seg_endpoints </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::pair&lt; <a class="el" href="namespaceMoby.html#ad8a5998be346e36d61d73fb858461b58">Point2d</a>, <a class="el" href="namespaceMoby.html#ad8a5998be346e36d61d73fb858461b58">Point2d</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>endpoints</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines the endpoints for a container of collinear Point2d objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>iterator to beginning of container of type Point2d </td></tr>
    <tr><td class="paramname">end</td><td>iterator to end of container of type Point2d </td></tr>
    <tr><td class="paramname">endpoints</td><td>the two farthest points on the segment on return </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6f3043f986e07262c02dba6be84170e6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ForwardIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Moby::CompGeom::determine_seg_endpoints </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::pair&lt; <a class="el" href="namespaceMoby.html#ad8a5998be346e36d61d73fb858461b58">Point2d</a> *, <a class="el" href="namespaceMoby.html#ad8a5998be346e36d61d73fb858461b58">Point2d</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>endpoints</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines the endpoints for a container of collinear Point2d* objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>iterator to beginning of container of type Point2d* </td></tr>
    <tr><td class="paramname">end</td><td>iterator to end of container of type Point2d* </td></tr>
    <tr><td class="paramname">endpoints</td><td>the two farthest points on the segment on return </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3a4c756ab335e006ef110377beeadd2e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ForwardIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double Moby::CompGeom::find_hs_interior_point </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ravelin::Origin3d &amp;&#160;</td>
          <td class="paramname"><em>point</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds an interior point of a set of halfspaces using linear programming. </p>
<p>The method used to find the interior point is of order O(n), where n is the number of halfspace constraints. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start</td><td>an iterator to the start of a collection of halfspaces, each of type std::pair&lt;Ravelin::Vector3, double&gt;, where the vector [nx ny nz] is the normal to the halfspace and the scalar is the offset 'd'; each halfspace will satisfy the equation nx*x + ny*y + nz*z &lt;= d </td></tr>
    <tr><td class="paramname">end</td><td>an iterator to the end of the collection </td></tr>
    <tr><td class="paramname">point</td><td>contains the interior point on return if successful </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the minimum distance from a halfspace of the interior point; if the point is negative, there is no interior point </dd></dl>

</div>
</div>
<a class="anchor" id="a3a4c756ab335e006ef110377beeadd2e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ForwardIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double Moby::CompGeom::find_hs_interior_point </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ravelin::Origin3d &amp;&#160;</td>
          <td class="paramname"><em>point</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds an interior point of a set of halfspaces using linear programming. </p>
<p>The method used to find the interior point is of order O(n), where n is the number of halfspace constraints. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start</td><td>an iterator to the start of a collection of halfspaces, each of type std::pair&lt;Ravelin::Vector3, double&gt;, where the vector [nx ny nz] is the normal to the halfspace and the scalar is the offset 'd'; each halfspace will satisfy the equation nx*x + ny*y + nz*z &lt;= d </td></tr>
    <tr><td class="paramname">end</td><td>an iterator to the end of the collection </td></tr>
    <tr><td class="paramname">point</td><td>contains the interior point on return if successful </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the minimum distance from a halfspace of the interior point; if the point is negative, there is no interior point </dd></dl>

</div>
</div>
<a class="anchor" id="a608392fd29f1b8a9ae94ef4422dde8ed"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ForwardIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double Moby::CompGeom::fit_plane </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ravelin::Vector3d &amp;&#160;</td>
          <td class="paramname"><em>normal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempts to fit a plane to a set of points. </p>
<p>The singular value decomposition is used to determine the plane that fits the points best in a least-squares sense. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td>the set of points (in 3D) </td></tr>
    <tr><td class="paramname">normal</td><td>contains the "best" normal, on return </td></tr>
    <tr><td class="paramname">offset</td><td>the offset such that, for any point on the plane x, &lt;normal, x&gt; = offset </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the maximum deviation from the plane </dd></dl>

</div>
</div>
<a class="anchor" id="a608392fd29f1b8a9ae94ef4422dde8ed"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ForwardIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double Moby::CompGeom::fit_plane </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ravelin::Vector3d &amp;&#160;</td>
          <td class="paramname"><em>normal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempts to fit a plane to a set of points. </p>
<p>The singular value decomposition is used to determine the plane that fits the points best in a least-squares sense. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td>the set of points (in 3D) </td></tr>
    <tr><td class="paramname">normal</td><td>contains the "best" normal, on return </td></tr>
    <tr><td class="paramname">offset</td><td>the offset such that, for any point on the plane x, &lt;normal, x&gt; = offset </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the maximum deviation from the plane </dd></dl>

</div>
</div>
<a class="anchor" id="a211b6044989fae14ca4f2fd9b095aa6d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CompGeom::PolygonLocationType CompGeom::in_tri </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceMoby.html#ad8a5998be346e36d61d73fb858461b58">Point2d</a>&#160;</td>
          <td class="paramname"><em>t</em>[3], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceMoby.html#ad8a5998be346e36d61d73fb858461b58">Point2d</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tol</em> = <code>NEAR_ZERO</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines the intersection of a point on a 2D triangle. </p>
<p>Adapted from O'Rourke, p. 236. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>the 2D triangle </td></tr>
    <tr><td class="paramname">p</td><td>a 2D point </td></tr>
    <tr><td class="paramname">tol</td><td>the tolerance with which to test for zero </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ePolygonOnVertex if p coincides with a vertex of t, ePolygonOnEdge if p is in the relative interior of an edge of t, ePolygonInside if p is in the relative interior of t, or ePolygonOutside otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="a89a8fb0483c6a0c8e2922e0bea05143b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CompGeom::PolygonLocationType CompGeom::in_tri </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMoby_1_1Triangle.html">Triangle</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceMoby.html#a846eb82dfba26e708e01316dc47a3e39">Point3d</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tol</em> = <code>NEAR_ZERO</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines the location of a point on a triangle. </p>
<dl class="section pre"><dt>Precondition</dt><dd>it has been determined that p lies in t's plane </dd></dl>

</div>
</div>
<a class="anchor" id="a4930b94d5cbbd573eaffe777a2b24d06"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ForwardIterator , class OutputIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">OutputIterator Moby::CompGeom::intersect_convex_polygons </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>pbegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>pend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>qbegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>qend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Ravelin::Vector3d &amp;&#160;</td>
          <td class="paramname"><em>normal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>isect_begin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Intersects two polygons in 3D. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pbegin</td><td>an iterator pointing to the container holding a ccw polygon </td></tr>
    <tr><td class="paramname">pend</td><td>the end of the container holding the first polygon </td></tr>
    <tr><td class="paramname">qbegin</td><td>an iterator pointing to the container holding a ccw polygon </td></tr>
    <tr><td class="paramname">qend</td><td>the end of the container holding the second polygon </td></tr>
    <tr><td class="paramname">normal</td><td>the normal to the polygons </td></tr>
    <tr><td class="paramname">isect_begin</td><td>on return, the polygon of intersection will be placed here with ccw orientation; this container must be big enough to hold the result (i.e., it must be at least of size min(p,q) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the iterator pointing to the end of the container of intersection </dd></dl>

</div>
</div>
<a class="anchor" id="a3dc207e68d29e300a53d81eff59ccc1f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ForwardIterator , class OutputIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">OutputIterator Moby::CompGeom::intersect_convex_polygons </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>pbegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>pend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>qbegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>qend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>isect_begin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Intersects two convex polygons in 2D. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pbegin</td><td>a random access iterator pointing to the container holding a ccw polygon (of Point2d) </td></tr>
    <tr><td class="paramname">pend</td><td>the end of the container holding the first polygon (of Point2d) </td></tr>
    <tr><td class="paramname">qbegin</td><td>a random access iterator pointing to the container holding a ccw polygon (of Point2d) </td></tr>
    <tr><td class="paramname">qend</td><td>the end of the container holding the second polygon (of Point2d) </td></tr>
    <tr><td class="paramname">isect_begin</td><td>on return, the polygon of intersection will be placed here with ccw orientation; this container must be big enough to hold the result (i.e., it must be at least of size min(p,q) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the iterator pointing to the end of the container of intersection </dd></dl>

</div>
</div>
<a class="anchor" id="a4930b94d5cbbd573eaffe777a2b24d06"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ForwardIterator , class OutputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OutputIterator Moby::CompGeom::intersect_convex_polygons </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>pbegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>pend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>qbegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>qend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Ravelin::Vector3d &amp;&#160;</td>
          <td class="paramname"><em>normal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>isect_begin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Intersects two polygons in 3D. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pbegin</td><td>an iterator pointing to the container holding a ccw polygon </td></tr>
    <tr><td class="paramname">pend</td><td>the end of the container holding the first polygon </td></tr>
    <tr><td class="paramname">qbegin</td><td>an iterator pointing to the container holding a ccw polygon </td></tr>
    <tr><td class="paramname">qend</td><td>the end of the container holding the second polygon </td></tr>
    <tr><td class="paramname">normal</td><td>the normal to the polygons </td></tr>
    <tr><td class="paramname">isect_begin</td><td>on return, the polygon of intersection will be placed here with ccw orientation; this container must be big enough to hold the result (i.e., it must be at least of size min(p,q) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the iterator pointing to the end of the container of intersection </dd></dl>

</div>
</div>
<a class="anchor" id="a3dc207e68d29e300a53d81eff59ccc1f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ForwardIterator , class OutputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OutputIterator Moby::CompGeom::intersect_convex_polygons </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>pbegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>pend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>qbegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>qend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>isect_begin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Intersects two convex polygons in 2D. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pbegin</td><td>a random access iterator pointing to the container holding a ccw polygon (of Point2d) </td></tr>
    <tr><td class="paramname">pend</td><td>the end of the container holding the first polygon (of Point2d) </td></tr>
    <tr><td class="paramname">qbegin</td><td>a random access iterator pointing to the container holding a ccw polygon (of Point2d) </td></tr>
    <tr><td class="paramname">qend</td><td>the end of the container holding the second polygon (of Point2d) </td></tr>
    <tr><td class="paramname">isect_begin</td><td>on return, the polygon of intersection will be placed here with ccw orientation; this container must be big enough to hold the result (i.e., it must be at least of size min(p,q) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the iterator pointing to the end of the container of intersection </dd></dl>

</div>
</div>
<a class="anchor" id="af9e08a7ade06867db6636a7f68375af0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class OutputIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">OutputIterator Moby::CompGeom::intersect_coplanar_tris </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMoby_1_1Triangle.html">Triangle</a> &amp;&#160;</td>
          <td class="paramname"><em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMoby_1_1Triangle.html">Triangle</a> &amp;&#160;</td>
          <td class="paramname"><em>t2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Ravelin::Vector3d &amp;&#160;</td>
          <td class="paramname"><em>normal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>begin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Intersects two coplanar triangles. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">normal</td><td>a normal to both triangles </td></tr>
    <tr><td class="paramname">begin</td><td>an iterator to a container that can hold the points of intersection (i.e., a container of size 6 or greater); on return, the container will contain a ccw polygon (in 3D) [orientation with respect to the given normal] </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the end of the container output </dd></dl>

</div>
</div>
<a class="anchor" id="af9e08a7ade06867db6636a7f68375af0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class OutputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OutputIterator Moby::CompGeom::intersect_coplanar_tris </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMoby_1_1Triangle.html">Triangle</a> &amp;&#160;</td>
          <td class="paramname"><em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMoby_1_1Triangle.html">Triangle</a> &amp;&#160;</td>
          <td class="paramname"><em>t2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Ravelin::Vector3d &amp;&#160;</td>
          <td class="paramname"><em>normal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>begin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Intersects two coplanar triangles. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">normal</td><td>a normal to both triangles </td></tr>
    <tr><td class="paramname">begin</td><td>an iterator to a container that can hold the points of intersection (i.e., a container of size 6 or greater); on return, the container will contain a ccw polygon (in 3D) [orientation with respect to the given normal] </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the end of the container output </dd></dl>

<p>References <a class="el" href="classMoby_1_1Triangle.html#ad297569558a16ba82514fe039ff10a02">Moby::Triangle::a</a>, and <a class="el" href="classMoby_1_1Triangle.html#aa372fced4cd344d563c2dfcce59b73bd">Moby::Triangle::get_vertex()</a>.</p>

</div>
</div>
<a class="anchor" id="ae97810ddcc85ef1d4177cb7fa9ce4028"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CompGeom::LineLineIntersectType CompGeom::intersect_lines </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceMoby.html#ad8a5998be346e36d61d73fb858461b58">Point2d</a> &amp;&#160;</td>
          <td class="paramname"><em>o1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Ravelin::Vector2d &amp;&#160;</td>
          <td class="paramname"><em>dir1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>min1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>max1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceMoby.html#ad8a5998be346e36d61d73fb858461b58">Point2d</a> &amp;&#160;</td>
          <td class="paramname"><em>o2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Ravelin::Vector2d &amp;&#160;</td>
          <td class="paramname"><em>dir2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>min2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>max2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether two lines/rays/segments in 2D intersect. </p>
<p>Taken from O'Rourke, p. 224. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">o1</td><td>the origin of the first line segment/ray (or a point on the line) </td></tr>
    <tr><td class="paramname">dir1</td><td>the direction of the first line </td></tr>
    <tr><td class="paramname">min1</td><td>the minimum parameter of the first line segment/ray/line </td></tr>
    <tr><td class="paramname">max1</td><td>the maximum parameter of the first line segment/ray/line </td></tr>
    <tr><td class="paramname">o2</td><td>the origin of the first line segment/ray (or a point on the line) </td></tr>
    <tr><td class="paramname">dir2</td><td>the direction of the second line </td></tr>
    <tr><td class="paramname">min2</td><td>the minimum parameter of the second line segment/ray/line </td></tr>
    <tr><td class="paramname">max2</td><td>the maximum parameter of the second line segment/ray/line </td></tr>
    <tr><td class="paramname">s1</td><td>on return of eLineLineIntersect/eLineLineVertex/eLineLineEdge contains the parameter on the first line of the first point of intersection (o1 + dir1*s1) </td></tr>
    <tr><td class="paramname">s2</td><td>on return of eLineLineEdge contains the parameter on the first line of the second point of intersection (o1 + dir1*s2) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the intersection type (edge, vertex, true_intersect, no_intersect); an edge intersection indicates that the lines/rays/segments collinearly overlap; vertex intersection indicates that an endpoint of one ray/segment is on the other line/ray/segment, but edge intersection does not hold; true_intersect indicates that the lines/rays/segments intersect at a single point. </dd></dl>

</div>
</div>
<a class="anchor" id="afaf7f5009c495acb1e0ed8b61890023b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool CompGeom::intersect_noncoplanar_tris </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMoby_1_1Triangle.html">Triangle</a> &amp;&#160;</td>
          <td class="paramname"><em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMoby_1_1Triangle.html">Triangle</a> &amp;&#160;</td>
          <td class="paramname"><em>t2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMoby.html#a846eb82dfba26e708e01316dc47a3e39">Point3d</a> &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMoby.html#a846eb82dfba26e708e01316dc47a3e39">Point3d</a> &amp;&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Intersects two non-coplanar triangles in 3D and returns the line of intersection. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t1</td><td>the first triangle </td></tr>
    <tr><td class="paramname">t2</td><td>the second triangle </td></tr>
    <tr><td class="paramname">p1</td><td>an endpoint of the line of intersection (on return) </td></tr>
    <tr><td class="paramname">p2</td><td>an endpoint of the line of intersection (on return) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> if the triangles intersect, <b>false</b> if they don't intersect or are coplanar </dd></dl>

<p>References <a class="el" href="classMoby_1_1Triangle.html#ad297569558a16ba82514fe039ff10a02">Moby::Triangle::a</a>, <a class="el" href="classMoby_1_1Triangle.html#a20d1e677982b8cba52105510778df65e">Moby::Triangle::b</a>, and <a class="el" href="classMoby_1_1Triangle.html#a1ace8212af951cd24bf16fcdd6522d21">Moby::Triangle::c</a>.</p>

</div>
</div>
<a class="anchor" id="a38094974cb3fa7c43811bd8a8e07f53f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ForwardIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Moby::CompGeom::intersect_seg_convex_polygon </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceMoby.html#ac1e78acf3c1ee806a04bb6d35eadcf46">LineSeg2</a> &amp;&#160;</td>
          <td class="paramname"><em>seg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>te</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>tl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tol</em> = <code>NEAR_ZERO</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the intersection of a convex polygon and a line segment. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>iterator pointing to start of collection of Point2d elements </td></tr>
    <tr><td class="paramname">end</td><td>iterator pointing to end of collection of Point2d elements </td></tr>
    <tr><td class="paramname">seg</td><td>the line segment </td></tr>
    <tr><td class="paramname">te</td><td>the parameter of the line segment for the beginning of the intersection; (1-te)*seg.first + te*seg.second is point of intersection </td></tr>
    <tr><td class="paramname">tl</td><td>the parameter of the line segment for the end of the intersection; (1-tl)*seg.first + tl*seg.second is point of intersection </td></tr>
    <tr><td class="paramname">tol</td><td>the tolerance for parallel lines </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> if the two intersect and <b>false</b> otherwise </dd></dl>
<dl class="section note"><dt>Note</dt><dd>polygon must be given in counter-clockwise order </dd>
<dd>
first vertex should not appear twice </dd>
<dd>
taken from <a href="http://geometryalgorithms.com">http://geometryalgorithms.com</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a0941a988f842850c466f497269719312"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ForwardIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool Moby::CompGeom::intersect_seg_convex_polygon </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceMoby.html#ac1e78acf3c1ee806a04bb6d35eadcf46">LineSeg2</a> &amp;&#160;</td>
          <td class="paramname"><em>seg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>te</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>tl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the intersection of a convex polygon and a line segment. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>iterator pointing to start of collection of Point2d elements </td></tr>
    <tr><td class="paramname">end</td><td>iterator pointing to end of collection of Point2d elements </td></tr>
    <tr><td class="paramname">seg</td><td>the line segment </td></tr>
    <tr><td class="paramname">te</td><td>the parameter of the line segment for the beginning of the intersection; (1-te)*seg.first + te*seg.second is point of intersection </td></tr>
    <tr><td class="paramname">tl</td><td>the parameter of the line segment for the end of the intersection; (1-tl)*seg.first + tl*seg.second is point of intersection </td></tr>
    <tr><td class="paramname">tol</td><td>the tolerance for parallel lines </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> if the two intersect and <b>false</b> otherwise </dd></dl>
<dl class="section note"><dt>Note</dt><dd>polygon must be given in counter-clockwise order </dd>
<dd>
first vertex should not appear twice </dd>
<dd>
taken from <a href="http://geometryalgorithms.com">http://geometryalgorithms.com</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a7f9edc2b410e801a80df7397b6cd40d3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CompGeom::SegPlaneIntersectType CompGeom::intersect_seg_plane </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMoby_1_1Triangle.html">Triangle</a> &amp;&#160;</td>
          <td class="paramname"><em>tri</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceMoby.html#ad691671b09efaee22f1758f1a1c3b2de">LineSeg3</a> &amp;&#160;</td>
          <td class="paramname"><em>seg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMoby.html#a846eb82dfba26e708e01316dc47a3e39">Point3d</a> &amp;&#160;</td>
          <td class="paramname"><em>isect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;&#160;</td>
          <td class="paramname"><em>big_dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tol</em> = <code>NEAR_ZERO</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines the intersection between a line segment and a plane in 3D. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tri</td><td>a 3D triangle that is fully contained in the plane to be intersected </td></tr>
    <tr><td class="paramname">seg</td><td>a 3D line segment </td></tr>
    <tr><td class="paramname">isect</td><td>the point of intersection (on return) </td></tr>
    <tr><td class="paramname">big_dim</td><td>the dimension of the largest component (on return) </td></tr>
    <tr><td class="paramname">NEAR_ZERO</td><td>the tolerance to test for zero </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the intersection type: eSegPlaneInPlane (segment lies wholly within the plane), eSegPlaneFirst (first vertex of segment is on the plane, but not the second), eSegPlaneSecond (second vertex of segment is on the plane, but not the first), eSegPlaneToSide (the segment lies strictly to one side or the other of the plane), or eSegPlaneOtherIntersect (segment intersects the plane, and in-plane, first, and second do not hold). </dd></dl>

</div>
</div>
<a class="anchor" id="a523384bf1a484781696fea303fb54d92"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ForwardIterator , class OutputIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">OutputIterator Moby::CompGeom::intersect_seg_polygon </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceMoby.html#ac1e78acf3c1ee806a04bb6d35eadcf46">LineSeg2</a> &amp;&#160;</td>
          <td class="paramname"><em>seg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>outbegin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the intersection of a polygon and a line segment. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>iterator pointing to start of collection of Point2d elements </td></tr>
    <tr><td class="paramname">end</td><td>iterator pointing to end of collection of Point2d elements </td></tr>
    <tr><td class="paramname">seg</td><td>the line segment </td></tr>
    <tr><td class="paramname">outbegin</td><td>an iterator to a container of type LineSeg2 that will store line segments on/in the polygon on return </td></tr>
    <tr><td class="paramname">tol</td><td>the tolerance for parallel lines </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ePolygonSegInside if the polygon </dd></dl>
<dl class="section note"><dt>Note</dt><dd>polygon must be given in counter-clockwise order </dd>
<dd>
first vertex should not appear twice </dd></dl>

</div>
</div>
<a class="anchor" id="a523384bf1a484781696fea303fb54d92"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ForwardIterator , class OutputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OutputIterator Moby::CompGeom::intersect_seg_polygon </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceMoby.html#ac1e78acf3c1ee806a04bb6d35eadcf46">LineSeg2</a> &amp;&#160;</td>
          <td class="paramname"><em>seg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>outbegin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the intersection of a polygon and a line segment. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>iterator pointing to start of collection of Point2d elements </td></tr>
    <tr><td class="paramname">end</td><td>iterator pointing to end of collection of Point2d elements </td></tr>
    <tr><td class="paramname">seg</td><td>the line segment </td></tr>
    <tr><td class="paramname">outbegin</td><td>an iterator to a container of type LineSeg2 that will store line segments on/in the polygon on return </td></tr>
    <tr><td class="paramname">tol</td><td>the tolerance for parallel lines </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ePolygonSegInside if the polygon </dd></dl>
<dl class="section note"><dt>Note</dt><dd>polygon must be given in counter-clockwise order </dd>
<dd>
first vertex should not appear twice </dd></dl>

</div>
</div>
<a class="anchor" id="a3ce296f8404a7c20fdf3abf4ee43b455"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CompGeom::SegTriIntersectType CompGeom::intersect_seg_tri </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceMoby.html#ad691671b09efaee22f1758f1a1c3b2de">LineSeg3</a> &amp;&#160;</td>
          <td class="paramname"><em>seg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMoby_1_1Triangle.html">Triangle</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMoby.html#a846eb82dfba26e708e01316dc47a3e39">Point3d</a> &amp;&#160;</td>
          <td class="paramname"><em>isect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMoby.html#a846eb82dfba26e708e01316dc47a3e39">Point3d</a> &amp;&#160;</td>
          <td class="paramname"><em>isect2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tol</em> = <code>NEAR_ZERO</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines the intersection between a line segment and triangle in 3D. </p>
<p>Adapted from O'Rourke, p. 238. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seg</td><td>a line segment in 3D </td></tr>
    <tr><td class="paramname">t</td><td>a triangle in 3D </td></tr>
    <tr><td class="paramname">isect</td><td>contains the point of intersection, if any (on return) </td></tr>
    <tr><td class="paramname">isect2</td><td>contains a second point of intersection, if the intersection type is seg_tri_inside, seg_tri_edge_overlap, or seg_tri_planar_intersect (on return) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>eSegTriInside (if the segment lies wholly within the face of the triangle), eSegTriVertex (if an endpoint of the segment coincides with a vertex of the triangle), eSegTriEdge (if an endpoint of the segment is in the relative interior of an edge of the triangle), eSegTriFace (if an endpoint of the segment is in the relative interior of the face of the triangle), eSegTriInclVertex (if the open segment includes a vertex of the triangle), eSegTriInclEdge (if the open segment includes a point in the relative interior of an edge of the triangle), eSegTriInclFace (if the open segment includes a point in the relative interior of a face of the triangle), eSegTriEdgeOverlap (if the segment overlaps one edge of the triangle [or vice versa]), eSegTriPlanarIntersect (if the segment lies partially within the face of the triangle), or eSegTriNoIntersect (if there is no intersection). </dd></dl>

</div>
</div>
<a class="anchor" id="ace838946d44581b9ca8a4b96e105b45b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CompGeom::SegTriIntersectType CompGeom::intersect_seg_tri </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceMoby.html#ac1e78acf3c1ee806a04bb6d35eadcf46">LineSeg2</a> &amp;&#160;</td>
          <td class="paramname"><em>seg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceMoby.html#ad8a5998be346e36d61d73fb858461b58">Point2d</a>&#160;</td>
          <td class="paramname"><em>tri</em>[3], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMoby.html#ad8a5998be346e36d61d73fb858461b58">Point2d</a> &amp;&#160;</td>
          <td class="paramname"><em>isect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMoby.html#ad8a5998be346e36d61d73fb858461b58">Point2d</a> &amp;&#160;</td>
          <td class="paramname"><em>isect2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tol</em> = <code>NEAR_ZERO</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines the intersection between a line segment and triangle in 2D. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seg</td><td>a line segment in 2D </td></tr>
    <tr><td class="paramname">tri</td><td>a triangle in 2D </td></tr>
    <tr><td class="paramname">isect</td><td>contains the point of intersection, if any (on return) </td></tr>
    <tr><td class="paramname">isect2</td><td>contains a second point of intersection, if the intersection type is eSegTriInside, eSegTriEdgeOverlap, or eSegTriPlanarIntersect (on return) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>eSegTriInside (if the segment lies wholly within the triangle face eSegTriVertex (if an endpoint of the segment coincides with a vertex of the triangle), eSegTriEdge (if an endpoint of the segment is in the relative interior of an edge of the triangle), eSegTriEdgeOverlap (if the segment overlaps one edge of the triangle [or vice versa]), eSegTriPlanarIntersect (if the segment lies partially within the face of the triangle), or eSegTriNoIntersect (if there is no intersection). </dd></dl>
<dl class="section note"><dt>Note</dt><dd>assumes triangle is oriented ccw </dd></dl>

</div>
</div>
<a class="anchor" id="ab5ddbc91ac40cdf7cfb1531aba4513ed"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CompGeom::SegSegIntersectType CompGeom::intersect_segs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceMoby.html#ad691671b09efaee22f1758f1a1c3b2de">LineSeg3</a> &amp;&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceMoby.html#ad691671b09efaee22f1758f1a1c3b2de">LineSeg3</a> &amp;&#160;</td>
          <td class="paramname"><em>s2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMoby.html#a846eb82dfba26e708e01316dc47a3e39">Point3d</a> &amp;&#160;</td>
          <td class="paramname"><em>isect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMoby.html#a846eb82dfba26e708e01316dc47a3e39">Point3d</a> &amp;&#160;</td>
          <td class="paramname"><em>isect2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether two line segments in 3D intersect. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s1</td><td>the points of the first line segment </td></tr>
    <tr><td class="paramname">s2</td><td>the points of the second line segment </td></tr>
    <tr><td class="paramname">isect</td><td>the point of intersection (if any) </td></tr>
    <tr><td class="paramname">isect2</td><td>the second point of intersection (for edge intersection) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the intersection type (edge, vertex, true_intersect, no_intersect); an edge intersection indicates that the segments collinearly overlap; vertex intersection indicates that an endpoint of one segment is on the other segment, but edge intersection does not hold; true_intersect indicates that the segments intersect at a single point. </dd></dl>

</div>
</div>
<a class="anchor" id="a5634dc46a6c8fcb354a3986ba8fdd825"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CompGeom::SegSegIntersectType CompGeom::intersect_segs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceMoby.html#ac1e78acf3c1ee806a04bb6d35eadcf46">LineSeg2</a> &amp;&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceMoby.html#ac1e78acf3c1ee806a04bb6d35eadcf46">LineSeg2</a> &amp;&#160;</td>
          <td class="paramname"><em>s2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMoby.html#ad8a5998be346e36d61d73fb858461b58">Point2d</a> &amp;&#160;</td>
          <td class="paramname"><em>isect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMoby.html#ad8a5998be346e36d61d73fb858461b58">Point2d</a> &amp;&#160;</td>
          <td class="paramname"><em>isect2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether two line segments in 2D intersect. </p>
<p>Taken from O'Rourke, p. 224. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s1</td><td>the points of the first line segment </td></tr>
    <tr><td class="paramname">s2</td><td>the points of the second line segment </td></tr>
    <tr><td class="paramname">isect</td><td>the point of intersection (if any) </td></tr>
    <tr><td class="paramname">isect2</td><td>the second point of intersection (for edge intersection) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the intersection type (edge, vertex, true_intersect, no_intersect); an edge intersection indicates that the segments collinearly overlap; vertex intersection indicates that an endpoint of one segment is on the other segment, but edge intersection does not hold; true_intersect indicates that the segments intersect at a single point. </dd></dl>

</div>
</div>
<a class="anchor" id="a47ded4bb24a0e1fa01c7500233250cff"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class OutputIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">OutputIterator Moby::CompGeom::intersect_segs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceMoby.html#ac1e78acf3c1ee806a04bb6d35eadcf46">LineSeg2</a> &amp;&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceMoby.html#ac1e78acf3c1ee806a04bb6d35eadcf46">LineSeg2</a> &amp;&#160;</td>
          <td class="paramname"><em>s2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>output_begin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Intersects two line segments in 2D. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seg1</td><td>the first line segment </td></tr>
    <tr><td class="paramname">seg2</td><td>the second line segment </td></tr>
    <tr><td class="paramname">output_begin</td><td>an iterator to the beginning of a container of Point2d; points of intersection will be stored here on return </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an iterator to the end of a container of Point2d; points of intersection will be stored here on return </dd></dl>

</div>
</div>
<a class="anchor" id="a47ded4bb24a0e1fa01c7500233250cff"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class OutputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OutputIterator Moby::CompGeom::intersect_segs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceMoby.html#ac1e78acf3c1ee806a04bb6d35eadcf46">LineSeg2</a> &amp;&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceMoby.html#ac1e78acf3c1ee806a04bb6d35eadcf46">LineSeg2</a> &amp;&#160;</td>
          <td class="paramname"><em>s2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>output_begin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Intersects two line segments in 2D. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seg1</td><td>the first line segment </td></tr>
    <tr><td class="paramname">seg2</td><td>the second line segment </td></tr>
    <tr><td class="paramname">output_begin</td><td>an iterator to the beginning of a container of Point2d; points of intersection will be stored here on return </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an iterator to the end of a container of Point2d; points of intersection will be stored here on return </dd></dl>

</div>
</div>
<a class="anchor" id="a3c5cb9a3599a7140a39642f5a5cb43af"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class OutputIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">OutputIterator Moby::CompGeom::intersect_tris </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceMoby.html#ad8a5998be346e36d61d73fb858461b58">Point2d</a>&#160;</td>
          <td class="paramname"><em>t1</em>[3], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceMoby.html#ad8a5998be346e36d61d73fb858461b58">Point2d</a>&#160;</td>
          <td class="paramname"><em>t2</em>[3], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>output_begin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Intersects two 2D triangles. </p>
<dl class="section note"><dt>Note</dt><dd>this method adapted from www.geometrictools.com </dd></dl>

</div>
</div>
<a class="anchor" id="a79f90f64a73d5111201fb2b624e8f779"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class OutputIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">OutputIterator Moby::CompGeom::intersect_tris </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMoby_1_1Triangle.html">Triangle</a> &amp;&#160;</td>
          <td class="paramname"><em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMoby_1_1Triangle.html">Triangle</a> &amp;&#160;</td>
          <td class="paramname"><em>t2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>begin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Intersects two triangles in 3D and returns the points of intersection. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>an iterator to a container that can hold the points of intersection (i.e., a container of size 6 or greater of Ravelin::Vector3 objects); on return, the container will contain a ccw polygon (in 3D) [orientation with respect to the given normal] </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the end of the container output </dd></dl>

</div>
</div>
<a class="anchor" id="a79f90f64a73d5111201fb2b624e8f779"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class OutputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OutputIterator Moby::CompGeom::intersect_tris </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMoby_1_1Triangle.html">Triangle</a> &amp;&#160;</td>
          <td class="paramname"><em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMoby_1_1Triangle.html">Triangle</a> &amp;&#160;</td>
          <td class="paramname"><em>t2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>begin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Intersects two triangles in 3D and returns the points of intersection. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>an iterator to a container that can hold the points of intersection (i.e., a container of size 6 or greater of Ravelin::Vector3 objects); on return, the container will contain a ccw polygon (in 3D) [orientation with respect to the given normal] </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the end of the container output </dd></dl>

<p>References <a class="el" href="classMoby_1_1Triangle.html#af65c9d1d701a63f9b96a33e638d9189e">Moby::Triangle::calc_normal()</a>.</p>

</div>
</div>
<a class="anchor" id="a3c5cb9a3599a7140a39642f5a5cb43af"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class OutputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OutputIterator Moby::CompGeom::intersect_tris </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceMoby.html#ad8a5998be346e36d61d73fb858461b58">Point2d</a>&#160;</td>
          <td class="paramname"><em>t1</em>[3], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceMoby.html#ad8a5998be346e36d61d73fb858461b58">Point2d</a>&#160;</td>
          <td class="paramname"><em>t2</em>[3], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>output_begin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Intersects two 2D triangles. </p>
<dl class="section note"><dt>Note</dt><dd>this method adapted from www.geometrictools.com </dd></dl>

</div>
</div>
<a class="anchor" id="a8a747cb185724f45bc91a227fc555287"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ForwardIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CompGeom::PolygonLocationType Moby::CompGeom::polygon_location </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceMoby.html#ad8a5998be346e36d61d73fb858461b58">Point2d</a> &amp;&#160;</td>
          <td class="paramname"><em>point</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether a 2D point is inside a polygon. </p>
<p>Adapted from O'Rourke, p. 244. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">polygon</td><td>a vector of points that describe a polygon (orientation irrelevant); each successive vertex in the vector is connected to the previous vector to make the polygon (polygon.front() and polygon.back() are connected as well) </td></tr>
    <tr><td class="paramname">point</td><td>the point to test </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>inside_poly if point is inside the polygon, on_vertex if the point coincides with a vertex, on_edge if the point lies on an edge of the polygon (but not a vertex), or outside_poly if the point is outside of the polygon </dd></dl>

</div>
</div>
<a class="anchor" id="a8a747cb185724f45bc91a227fc555287"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ForwardIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CompGeom::PolygonLocationType Moby::CompGeom::polygon_location </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceMoby.html#ad8a5998be346e36d61d73fb858461b58">Point2d</a> &amp;&#160;</td>
          <td class="paramname"><em>point</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether a 2D point is inside a polygon. </p>
<p>Adapted from O'Rourke, p. 244. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">polygon</td><td>a vector of points that describe a polygon (orientation irrelevant); each successive vertex in the vector is connected to the previous vector to make the polygon (polygon.front() and polygon.back() are connected as well) </td></tr>
    <tr><td class="paramname">point</td><td>the point to test </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>inside_poly if point is inside the polygon, on_vertex if the point coincides with a vertex, on_edge if the point lies on an edge of the polygon (but not a vertex), or outside_poly if the point is outside of the polygon </dd></dl>

</div>
</div>
<a class="anchor" id="a5bb1613349c111d5fdd1f200e0c5f516"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ForwardIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Moby::CompGeom::project_plane </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Ravelin::Vector3d &amp;&#160;</td>
          <td class="paramname"><em>normal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Projects a set of points onto a plane. </p>
<p>This method is intended to be used with <a class="el" href="classMoby_1_1CompGeom.html#a608392fd29f1b8a9ae94ef4422dde8ed" title="Attempts to fit a plane to a set of points. ">fit_plane()</a> to project the set of points exactly onto a plane; note that this method is unnecessary if the points fit a plane exactly. </p>

</div>
</div>
<a class="anchor" id="a5bb1613349c111d5fdd1f200e0c5f516"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ForwardIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Moby::CompGeom::project_plane </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Ravelin::Vector3d &amp;&#160;</td>
          <td class="paramname"><em>normal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Projects a set of points onto a plane. </p>
<p>This method is intended to be used with <a class="el" href="classMoby_1_1CompGeom.html#a608392fd29f1b8a9ae94ef4422dde8ed" title="Attempts to fit a plane to a set of points. ">fit_plane()</a> to project the set of points exactly onto a plane; note that this method is unnecessary if the points fit a plane exactly. </p>

</div>
</div>
<a class="anchor" id="a83aacfe3503a7e13a714b28b621feaf3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool CompGeom::query_intersect_tri_tri </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMoby_1_1Triangle.html">Triangle</a> &amp;&#160;</td>
          <td class="paramname"><em>t0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMoby_1_1Triangle.html">Triangle</a> &amp;&#160;</td>
          <td class="paramname"><em>t1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Determines whether two triangles intersect. </p>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> if the triangles intersect </dd></dl>
<dl class="section note"><dt>Note</dt><dd>adapted from www.geometrictools.com </dd></dl>

<p>References <a class="el" href="classMoby_1_1Triangle.html#ad297569558a16ba82514fe039ff10a02">Moby::Triangle::a</a>, <a class="el" href="classMoby_1_1Triangle.html#a20d1e677982b8cba52105510778df65e">Moby::Triangle::b</a>, and <a class="el" href="classMoby_1_1Triangle.html#a1ace8212af951cd24bf16fcdd6522d21">Moby::Triangle::c</a>.</p>

</div>
</div>
<a class="anchor" id="a405fb3b1e042639c67eb8e67283ea28a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool Moby::CompGeom::rel_equal </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tol</em> = <code>NEAR_ZERO</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether two numbers are relatively/absolutely equal to within some tolerance. </p>
<p>If the numbers are both smaller than zero, an absolute tolerance is used; otherwise, a relative tolerance is used. </p>
<dl class="section note"><dt>Note</dt><dd>rationale for why this test is useful: [Ericson, 2005] p. 443 </dd></dl>

<p>Referenced by <a class="el" href="classMoby_1_1BoxPrimitive.html#a4db9695a126612c821bc962db8d679a3">Moby::BoxPrimitive::calc_dist_and_normal()</a>.</p>

</div>
</div>
<a class="anchor" id="ac799f5a36a9ff677f8bd5a0f9c65269a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ForwardIterator , class OutputIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">OutputIterator Moby::CompGeom::to_2D </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>begin_source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>end_source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Ravelin::Matrix3d &amp;&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>begin_target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Converts a collection of Ravelin::Vector3d objects to Point2d objects </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source_begin</td><td>an iterator pointing to the beginning of the Ravelin::Vector3d objects </td></tr>
    <tr><td class="paramname">source_end</td><td>an iterator pointing to the end of the Ravelin::Vector3d objects </td></tr>
    <tr><td class="paramname">begin_target</td><td>an iterator pointing to the beginning of the Point2d objects </td></tr>
    <tr><td class="paramname">R</td><td>the projection matrix from 3D to 2D (on return) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the end of the output range </dd></dl>
<dl class="section note"><dt>Note</dt><dd>the size of the target collection must be equal to the size of the source collection </dd></dl>

</div>
</div>
<a class="anchor" id="a0a7cdc93c837ca7dfb50316ce0987221"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ForwardIterator , class OutputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OutputIterator Moby::CompGeom::to_2D </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>begin_source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>end_source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Ravelin::Matrix3d &amp;&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>begin_target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Converts a collection of Ravelin::Vector3d objects to Point2d objects </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source_begin</td><td>an iterator pointing to the beginning of the Ravelin::Vector3d objects </td></tr>
    <tr><td class="paramname">source_end</td><td>an iterator pointing to the end of the Ravelin::Vector3d objects </td></tr>
    <tr><td class="paramname">begin_target</td><td>an iterator pointing to the beginning of the Point2d objects </td></tr>
    <tr><td class="paramname">R</td><td>the projection matrix from 3D to 2D (on return) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the end of the output range </dd></dl>
<dl class="section note"><dt>Note</dt><dd>the size of the target collection must be equal to the size of the source collection </dd></dl>

</div>
</div>
<a class="anchor" id="a2b1a0f6f816a5b0b7aa506d2f0a04d72"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ForwardIterator , class OutputIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">OutputIterator Moby::CompGeom::to_3D </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>begin_source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>end_source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>begin_target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Ravelin::Matrix3d &amp;&#160;</td>
          <td class="paramname"><em>RT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Converts a collection of Point2d objects to Ravelin::Vector3d objects </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source_begin</td><td>an iterator pointing to the beginning of the Ravelin::Vector3d objects </td></tr>
    <tr><td class="paramname">source_end</td><td>an iterator pointing to the end of the Ravelin::Vector3d objects </td></tr>
    <tr><td class="paramname">begin_target</td><td>an iterator pointing to the beginning of the Point2d objects </td></tr>
    <tr><td class="paramname">R</td><td>the projection matrix from 2D to 3D </td></tr>
    <tr><td class="paramname">offset</td><td>the offset that must be added to the Z-coordinate of points projected back from 2D to 3D </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the end of the output range </dd></dl>
<dl class="section note"><dt>Note</dt><dd>the size of the target collection must be equal to the size of the source collection </dd></dl>

</div>
</div>
<a class="anchor" id="ac4a9a799d9237b6f0e2a11ece24b39cd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ForwardIterator , class OutputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OutputIterator Moby::CompGeom::to_3D </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>begin_source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>end_source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>begin_target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Ravelin::Matrix3d &amp;&#160;</td>
          <td class="paramname"><em>RT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Converts a collection of Point2d objects to Ravelin::Vector3d objects </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source_begin</td><td>an iterator pointing to the beginning of the Ravelin::Vector3d objects </td></tr>
    <tr><td class="paramname">source_end</td><td>an iterator pointing to the end of the Ravelin::Vector3d objects </td></tr>
    <tr><td class="paramname">begin_target</td><td>an iterator pointing to the beginning of the Point2d objects </td></tr>
    <tr><td class="paramname">R</td><td>the projection matrix from 2D to 3D </td></tr>
    <tr><td class="paramname">offset</td><td>the offset that must be added to the Z-coordinate of points projected back from 2D to 3D </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the end of the output range </dd></dl>
<dl class="section note"><dt>Note</dt><dd>the size of the target collection must be equal to the size of the source collection </dd></dl>

</div>
</div>
<a class="anchor" id="a8e37a986917fca0b8a38fffd559b206f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ForwardIterator , class OutputIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">OutputIterator Moby::CompGeom::triangulate_convex_polygon </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>source_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>source_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>target_begin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Triangulates a convex polygon in O(n) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source_begin</td><td>the starting iterator to a connected, ccw-oriented, convex polygon; additionally, the first point is assumed to be connected to the last </td></tr>
    <tr><td class="paramname">source_end</td><td>the ending iterator to the polygon container </td></tr>
    <tr><td class="paramname">target_begin</td><td>the starting iterator to the container of triangles </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the ending iterator to the container of triangles </dd></dl>

</div>
</div>
<a class="anchor" id="a8e37a986917fca0b8a38fffd559b206f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ForwardIterator , class OutputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OutputIterator Moby::CompGeom::triangulate_convex_polygon </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>source_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>source_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>target_begin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Triangulates a convex polygon in O(n) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source_begin</td><td>the starting iterator to a connected, ccw-oriented, convex polygon; additionally, the first point is assumed to be connected to the last </td></tr>
    <tr><td class="paramname">source_end</td><td>the ending iterator to the polygon container </td></tr>
    <tr><td class="paramname">target_begin</td><td>the starting iterator to the container of triangles </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the ending iterator to the container of triangles </dd></dl>

</div>
</div>
<a class="anchor" id="ab478434f45c68c365ceca762b77ffc0e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class BidirectionalIterator , class OutputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OutputIterator Moby::CompGeom::triangulate_polygon_2D </td>
          <td>(</td>
          <td class="paramtype">BidirectionalIterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BidirectionalIterator&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>outbegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Triangulates a polygon (in 2D) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>a bidirectional iterator to a container of Point2d objects </td></tr>
    <tr><td class="paramname">end</td><td>a bidirectional iterator to a container of Point2d objects </td></tr>
    <tr><td class="paramname">outbegin</td><td>an iterator to a container of type std::pair&lt;const Point2d*, const Point2d*&gt;; output will be written here </td></tr>
    <tr><td class="paramname">tol</td><td>tolerance to test for zero </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an iterator to the end of the output </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000002">Todo:</a></b></dt><dd>re-implement using faster O(n lg n) algorithm (currently runs in O(n^2) time) </dd></dl>

</div>
</div>
<a class="anchor" id="a5841bb99e1471e9416786db68b8b6d9f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class BidirectionalIterator , class OutputIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">OutputIterator Moby::CompGeom::triangulate_polygon_2D </td>
          <td>(</td>
          <td class="paramtype">BidirectionalIterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BidirectionalIterator&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>outbegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tol</em> = <code>NEAR_ZERO</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Triangulates a polygon (in 2D) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>a bidirectional iterator to a container of Point2d objects </td></tr>
    <tr><td class="paramname">end</td><td>a bidirectional iterator to a container of Point2d objects </td></tr>
    <tr><td class="paramname">outbegin</td><td>an iterator to a container of type std::pair&lt;const Point2d*, const Point2d*&gt;; output will be written here </td></tr>
    <tr><td class="paramname">tol</td><td>tolerance to test for zero </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an iterator to the end of the output </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000001">Todo:</a></b></dt><dd>re-implement using faster O(n lg n) algorithm (currently runs in O(n^2) time) </dd></dl>

</div>
</div>
<a class="anchor" id="adbf2414a41a664c74a56b8162e13f2e6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CompGeom::VisibilityType CompGeom::volume_sign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceMoby.html#a846eb82dfba26e708e01316dc47a3e39">Point3d</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceMoby.html#a846eb82dfba26e708e01316dc47a3e39">Point3d</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceMoby.html#a846eb82dfba26e708e01316dc47a3e39">Point3d</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceMoby.html#a846eb82dfba26e708e01316dc47a3e39">Point3d</a> &amp;&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tol</em> = <code>NEAR_ZERO</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the sign of the volume of a tetrahedron composed of vertices a, b, c, d. </p>
<dl class="section return"><dt>Returns</dt><dd>-1 if d is "visible" from the plane of (a,b,c); 0 if the a,b,c, and d are coplanar, and +1 otherwise </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/home/drum/Moby/include/Moby/<a class="el" href="CompGeom_8h_source.html">CompGeom.h</a></li>
<li>/home/drum/Moby/include/Moby/CompGeom.inl</li>
<li>/home/drum/Moby/src/CompGeom.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Mar 23 2016 11:07:05 for Moby by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
